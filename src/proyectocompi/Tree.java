/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectocompi;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;

/**
 *
 * @author Usuario
 */
public class Tree extends javax.swing.JFrame {

    /**
     * Creates new form Tree
     */
    public Tree() {
        initComponents();
        this.jTree1.setModel(new DefaultTreeModel(new DefaultMutableTreeNode("PROGRAM")));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jDialog1 = new javax.swing.JDialog();
        jScrollPane3 = new javax.swing.JScrollPane();
        tablaCuadruplos = new javax.swing.JTable();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTree1 = new javax.swing.JTree();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        ShowTables = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();

        tablaCuadruplos.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        jScrollPane3.setViewportView(tablaCuadruplos);

        javax.swing.GroupLayout jDialog1Layout = new javax.swing.GroupLayout(jDialog1.getContentPane());
        jDialog1.getContentPane().setLayout(jDialog1Layout);
        jDialog1Layout.setHorizontalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDialog1Layout.createSequentialGroup()
                .addGap(44, 44, 44)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 452, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(54, Short.MAX_VALUE))
        );
        jDialog1Layout.setVerticalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jDialog1Layout.createSequentialGroup()
                .addContainerGap(14, Short.MAX_VALUE)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 370, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jScrollPane1.setViewportView(jTree1);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane2.setViewportView(jTextArea1);

        jButton1.setText("Compilar");
        jButton1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButton1MouseClicked(evt);
            }
        });

        jButton2.setText("Generar Lexer y Parser");
        jButton2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButton2MouseClicked(evt);
            }
        });

        ShowTables.setText("Mostrar Tablas de Simbolos");
        ShowTables.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                ShowTablesMouseClicked(evt);
            }
        });

        jButton3.setText("Cuadruplos");
        jButton3.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButton3MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(34, 34, 34)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButton2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ShowTables)
                        .addGap(18, 18, 18)
                        .addComponent(jButton3))
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 523, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 638, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(39, 39, 39)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton1)
                            .addComponent(jButton2)
                            .addComponent(ShowTables)
                            .addComponent(jButton3))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 636, Short.MAX_VALUE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton1MouseClicked
        // TODO add your handling code here:
        this.jTextArea1.setText("");
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new File("C:/Users/Usuario/Documents/Periodo I 2018/Compiladores I/ProyectoCompiladores"));
        int value = chooser.showOpenDialog(jTree1);

        if (value == JFileChooser.APPROVE_OPTION) {
            try {
                File file = chooser.getSelectedFile();
                FileReader fr = new FileReader(file);
                BufferedReader br = new BufferedReader(fr);
                String line = "";
                while (line != null) {
                    line = br.readLine();
                    this.jTextArea1.append(line);
                    this.jTextArea1.append("\n");
                }
                this.runParser(file.getName());
                JOptionPane.showMessageDialog(this, "Parseado por completo");
            } catch (FileNotFoundException ex) {
                JOptionPane.showMessageDialog(this, "ERROR");
            } catch (IOException ex) {
                Logger.getLogger(Tree.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//GEN-LAST:event_jButton1MouseClicked

    private void jButton2MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton2MouseClicked
        // TODO add your handling code here:
        generateLexer();
        generateParser();
        moveFile("AnalizadorSintactico.java");
        moveFile("sym.java");
        JOptionPane.showMessageDialog(this, "Se genero correctamente");
    }//GEN-LAST:event_jButton2MouseClicked

    private void ShowTablesMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_ShowTablesMouseClicked
        // TODO add your handling code here:
        DefaultTreeModel model = new DefaultTreeModel(new DefaultMutableTreeNode());
        this.showTree(null, this.symbolTables.root, model, (DefaultMutableTreeNode) model.getRoot());
    }//GEN-LAST:event_ShowTablesMouseClicked

    private void jButton3MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton3MouseClicked
        // TODO add your handling code here:
        this.optimizer(this.cuadruplos.list);
        this.showCuadruplos();
    }//GEN-LAST:event_jButton3MouseClicked

    public void generateLexer() {
        String[] params = new String[3];
        params[0] = "-d";
        params[1] = "src/proyectocompi";
        params[2] = "src/proyectocompi/lexer.flex";

        try {
            jflex.Main.generate(params);
            System.out.println("Se genero lexer");
        } catch (Exception e) {
        }
    }

    public void generateParser() {
        String[] params2 = new String[3];
        params2[0] = "-parser";
        params2[1] = "AnalizadorSintactico";
        params2[2] = "src/proyectocompi/Asintactico.cup";

        try {
            java_cup.Main.main(params2);
            System.out.println("Se genero el Parser");
        } catch (Exception e) {
        }
    }

    public boolean moveFile(String archNombre) {
        boolean efectuado = false;
        File arch = new File(archNombre);
        if (arch.exists()) {
            System.out.println("\n*** Moviendo " + arch + " \n***");
            Path currentRelativePath = Paths.get("");
            String nuevoDir = currentRelativePath.toAbsolutePath().toString()
                    + File.separator + "src" + File.separator
                    + "proyectocompi" + File.separator + arch.getName();
            File archViejo = new File(nuevoDir);
            archViejo.delete();
            if (arch.renameTo(new File(nuevoDir))) {
                System.out.println("\n*** Generado " + archNombre + "***\n");
                efectuado = true;
            } else {
                System.out.println("\n*** No movido " + archNombre + " ***\n");
            }
        } else {
            System.out.println("\n*** Codigo no existente ***\n");
        }
        return efectuado;
    }

    public void runParser(String file) throws FileNotFoundException {
        DefaultTreeModel model = new DefaultTreeModel(new DefaultMutableTreeNode());
        Lexer lexer = new Lexer(new FileReader(file));
        AnalizadorSintactico parser = new AnalizadorSintactico(lexer);
        ArrayList arr = new ArrayList();
        this.symbolTables = new MyTree(new TreeNode("Symbol Tables", null));
        result = new MyTree();
        table = new SymbolTable("Functions");
        node = this.symbolTables.root;

        try {
            arr = (ArrayList) parser.parse().value;
            result = (MyTree) arr.get(0);
            table.list = (ArrayList<Row>) arr.get(1);
            table.blockID = this.blockID;
            this.blockID++;
            this.showTree(null, result.root, model, (DefaultMutableTreeNode) model.getRoot());
            System.out.println("Parseado correctamente");
        } catch (Exception e) {
            e.printStackTrace();
        }

        this.addTableToTree(table, this.symbolTables.root);
        System.out.println("");
        System.out.println("***************ANALISIS SEMANTICO*********************");
        this.evaluateTree(this.result.root, this.result.root.getLefterSon());
        if (!this.hasSemanticErrors) {
            this.cuadruplos = new IntermediateTable();
            this.cuadruplos.list.add(new RowIntermediate("F_ETIQ", this.globalTag, "0", ""));
            this.currentF_ETIQ = this.globalTag;
            TreeNode node = this.getLeftestSon(result.root);
            this.inspectTree(node.parent, node);
            this.cuadruplos.list.add(new RowIntermediate("F_ETIQ2", this.currentF_ETIQ, "", ""));
            //JOptionPane.showMessageDialog(this, "Codigo Final generado correctamente");
            //String fileName = JOptionPane.showInputDialog("Seleccion un mombre para su asm");
            //this.generateASM(fileName);
            this.generateFinalCode();
        } else {
            JOptionPane.showMessageDialog(this, "Se han encontrado errores semanticos");
        }
    }

    public void addTableToTree(SymbolTable table, TreeNode parent) {
        TreeNode node = new TreeNode(table, parent);
        parent.addSon(node);
        this.node = node;
    }

    public SymbolTable getTableFromNode(TreeNode node) {
        return (SymbolTable) node.value;
    }

    public void evaluateTree(TreeNode parent, TreeNode node) {
        evaluateNode(node);
        if (node.isParent()) {
            evaluateTree(node, node.getLefterSon());
        }

        verifyExitFromBranch(node);
        if (node.hasRightBrother()) {
            evaluateTree(parent, node.getRightBrother());
        }
    }

    public void evaluateNode(TreeNode node) {
        line = node.line;
        column = node.column;
        if (node.value.toString().equals("Declaration")) {
            this.type = this.getLeftestSon(node).value.toString();
            this.evaluateDeclaration(node);
        } else if (node.value.toString().equals("Assignment")) {
            this.evaluateAssignment(node, false);
        } else if (node.value.toString().equals("Main")) {
            this.table = new SymbolTable("Main");
            this.table.blockID = this.blockID;
            this.blockID++;
            this.addTableToTree(table, this.symbolTables.root);
            parentType = "int";
            parent = "Main";
            returnCounter = 0;
            hasReturn = false;
        } else if (node.value.toString().equals("function")) {
            this.table = new SymbolTable(node.getLefterSon().value.toString());
            this.table.blockID = this.blockID;
            this.blockID++;
            this.offsetStack.push(this.offset);
            this.offset = 0;
            this.isFirst = true;
            this.addTableToTree(table, this.symbolTables.root);
            parentType = node.getHijos().get(1).value.toString();
            parent = node.getLefterSon().value.toString();
            returnCounter = 0;
            hasReturn = false;
        } else if (node.value.toString().equals("Call")) {
            this.evaluateCall(node, "", false);
        } else if (node.value.toString().equals("If")) {
            this.table = new SymbolTable("If");
            this.table.blockID = this.blockID;
            this.blockID++;
            this.offsetStack.push(this.offset);
            this.addTableToTree(this.table, this.node);
        } else if (node.value.toString().equals("While")) {
            this.table = new SymbolTable("While");
            this.table.blockID = this.blockID;
            this.blockID++;
            this.offsetStack.push(this.offset);
            this.addTableToTree(table, this.node);
        } else if (node.value.toString().equals("ElseIf")) {
            this.table = new SymbolTable("Elseif");
            this.table.blockID = this.blockID;
            this.blockID++;
            this.offsetStack.push(this.offset);
            this.addTableToTree(table, this.node);
        } else if (node.value.toString().equals("Else")) {
            this.table = new SymbolTable("Else");
            this.table.blockID = this.blockID;
            this.blockID++;
            this.offsetStack.push(this.offset);
            this.addTableToTree(table, this.node);
        } else if (node.value.toString().equals("For")) {
            this.table = new SymbolTable("For");
            this.table.blockID = this.blockID;
            this.blockID++;
            this.offsetStack.push(this.offset);
            this.addTableToTree(table, this.node);
            this.evaluateFor(node);
        } else if (node.value.toString().equals("Case")) {
            this.table = new SymbolTable("Case " + node.getLefterSon().value.toString());
            this.table.blockID = this.blockID;
            this.blockID++;
            this.addTableToTree(table, this.node);
            this.offsetStack.push(this.offset);
        } else if (node.value.toString().equals("ArrayElementAssignment")) {
            this.evaluateArrayElementAssignment(node);
        } else if (node.value.toString().equals("Equal")) {
            this.evaluateComparison(node, false);
        } else if (node.value.toString().equals("GreaterThan")) {
            this.evaluateComparison(node, true);
        } else if (node.value.toString().equals("LessThan")) {
            this.evaluateComparison(node, true);
        } else if (node.value.toString().equals("Different")) {
            this.evaluateComparison(node, false);
        } else if (node.value.toString().equals("GreaterEqual")) {
            this.evaluateComparison(node, true);
        } else if (node.value.toString().equals("LessEqual")) {
            this.evaluateComparison(node, true);
        } else if (node.value.toString().equals("Switch")) {
            this.evaluateSwitch(node);
        } else if (node.value.toString().equals("Write")) {
            for (int i = 0; i < node.getHijos().size(); i++) {
                if (node.getHijos().get(i).value.toString().equals("Call")) {
                    this.evaluateCall(node.getHijos().get(i), "void", true);
                } else {
                    this.getNodeType(node.getHijos().get(i));
                }
            }
        } else if (node.value.toString().equals("Read")) {
            if (!this.existInTable(this.node, node.getLefterSon().value.toString())) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico. Variable " + node.getLefterSon().value.toString()
                        + " no ha sido declarada");
            } else {
                node.getLefterSon().tableID = this.currentID;
            }
        } else if (node.value.toString().equals("Return")) {
            this.evaluateReturn(node);
            this.returnCounter++;
        } else if (node.value.toString().equals("Parameter")) {
            String type = node.getLefterSon().value.toString();
            int size = this.getTypeSize(type);
            this.temporalRow = new Row(node.getHijos().get(1).value.toString(),
                    node.getLefterSon().value.toString());
            this.paramsOffset += size;
            this.temporalRow.offset = paramsOffset;
            this.temporalRow.isParameter = true;
            this.getTableFromNode(this.node).list.add(temporalRow);
        } else if (node.value.toString().equals("Body")) {
            if (node.parent.value.toString().equals("function")) {
                this.paramsOffset = 0;
                this.isFirstParam = true;
            }
        }
    }

    public void verifyExitFromBranch(TreeNode node) {
        if (node.value.toString().equals("Body")) {
            if (node.parent.value.toString().equals("If")) {
                this.node = this.node.getParent();
                this.offset = this.offsetStack.pop();
            }
        } else if (node.value.toString().equals("While")) {
            this.node = this.node.getParent();
            this.offset = this.offsetStack.pop();
        } else if (node.value.toString().equals("ElseIf")) {
            this.node = this.node.getParent();
            this.offset = this.offsetStack.pop();
        } else if (node.value.toString().equals("Else")) {
            this.node = this.node.getParent();
            this.offset = this.offsetStack.pop();
        } else if (node.value.toString().equals("For")) {
            this.node = this.node.getParent();
            this.offset = this.offsetStack.pop();
        } else if (node.value.toString().equals("Case")) {
            this.node = this.node.getParent();
            this.offset = this.offsetStack.pop();
        } else if (node.value.equals("Main")) {
            if (returnCounter != 1) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "El main debe tener slo un return");
            }
            if (!hasReturn) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + " El main debe tener un return en el cuerpo principal");
            }

            returnCounter = 0;
        } else if (node.value.equals("function")) {
            if (returnCounter < 1) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "La funcion " + this.parent + " debe tener al menos un return");
            }

            if (!hasReturn) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "La funcion " + this.parent
                        + " debe tener un return en el cuerpo principal");
            }
            returnCounter = 1;
        }
    }

    public void evaluateReturn(TreeNode node) {
        TreeNode value = node.getLefterSon();
        String returnType = "";

        if (value.value.toString().equals("Call")) {
            if (this.evaluateCall(value, "void", true)) {
                returnType = this.actualType;
            }
        } else {
            returnType = this.getNodeType(value);
            System.out.println("Mi tipoo es: " + returnType);
            node.getLefterSon().tableID = this.currentID;
        }

        if (!this.parentType.equals(returnType)) {
            this.hasSemanticErrors = true;
            System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                    + "El retorno de " + parent
                    + " deber ser de tipo " + this.parentType);
        }
        this.hasReturn = hasReturnInMainBody(node);
    }

    public boolean hasReturnInMainBody(TreeNode node) {
        node = node.getParent().getParent();
        if (node.value.toString().equals("Main") || node.value.toString().equals("function")) {
            return true;
        }
        return false;
    }

    public void evaluateFor(TreeNode node) {
        line = node.getLine();
        column = node.getColumn();
        node = node.getLefterSon();
        TreeNode variable = node.getLefterSon();
        TreeNode range = node.getHijos().get(1);
        TreeNode step = node.getHijos().get(2);
        String id = variable.getHijos().get(1).value.toString();

        if (variable.getLefterSon().value.equals("int")) {
            if (this.existInTable(this.node, id)) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "La variable " + id + " ya ha sido declarada");
                return;
            } else {
                variable.tableID = this.blockID - 1;
            }
        } else {
            this.hasSemanticErrors = true;
            System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                    + "La variable del for debe ser de tipo int");
            return;
        }

        if (!(this.getNodeType(range.getHijos().get(0)).equals("int") && this.getNodeType(range.getHijos().get(1)).equals("int"))) {
            this.hasSemanticErrors = true;
            System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                    + "Los rangos del for deben ser int");
            return;
        }

        if (!this.getNodeType(step.getLefterSon()).equals("int")) {
            this.hasSemanticErrors = true;
            System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                    + "El valor de incremento del for debe ser de tipo int");
            return;
        }
        this.temporalRow = new Row(id, "int");
        int size = this.getTypeSize("int");
        this.offset += size;
        this.temporalRow.offset = this.offset;
        this.getTableFromNode(this.node).list.add(this.temporalRow);
        variable.getHijos().get(1).tableID = this.getTableFromNode(this.node).blockID;
    }

    public void evaluateSwitch(TreeNode node) {
        String id = node.getLefterSon().getLefterSon().value.toString();
        String type = "";
        String caseValue = "";
        String caseValueType = "";

        if (this.existInTable(this.node, id)) {
            type = this.getTypeById(this.node, id);
            for (int i = 1; i < node.getHijos().size() - 1; i++) {
                caseValue = node.getHijos().get(i).getLefterSon().getLefterSon().value.toString();
                if (Character.isDigit(caseValue.charAt(0))) {
                    caseValueType = "int";
                    node.getLefterSon().getLefterSon().tableID = this.currentID;
                } else {
                    if (caseValue.length() == 1) {
                        caseValueType = "char";
                        node.getLefterSon().getLefterSon().tableID = this.currentID;
                    } else {
                        this.hasSemanticErrors = true;
                        System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                                + "La variable del switch debe ser char o int");
                        //return;
                    }
                }

                if (!type.equals(caseValueType)) {
                    this.hasSemanticErrors = true;
                    System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                            + "Los valores del case deben ser de tipo " + type);
                    //return;
                }
            }
        } else {
            this.hasSemanticErrors = true;
            System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                    + "La variable " + id + " no ha sido declarada.");
        }
    }

    public void evaluateComparison(TreeNode node, boolean integers) {
        String type1 = "";
        String type2 = "";

        if (node.getLefterSon().value.toString().equals("Call")) {
            if (this.evaluateCall(node.getLefterSon(), "void", true)) {
                type1 = this.actualType;
            }
        } else {
            type1 = this.getNodeType(node.getLefterSon());
        }

        if (node.getHijos().get(1).value.toString().equals("Call")) {
            if (this.evaluateCall(node.getHijos().get(1), "void", true)) {
                type2 = this.actualType;
            }
        } else {
            type2 = this.getNodeType(node.getHijos().get(1));
        }
        if (integers) {
            if (!(type1.equals("int") && type2.equals("int"))) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "Las comparaciones deben ser entre valores de tipo int");
            }
        } else {
            if (!type1.equals(type2)) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "Las comparaciones deben ser entre valores del mismo tipo");
            }
        }
    }

    public void evaluateDeclaration(TreeNode node) {
        int size = 0;
        for (int i = 1; i < node.hijos.size(); i++) {
            if (!node.hijos.get(i).value.toString().equals("Assignment")) {
                if (!this.existInTable(this.node, node.hijos.get(i).value.toString())) {
                    if (this.type.contains("[]")) {
                        this.hasSemanticErrors = true;
                        System.out.println("Error semantico en linea " + line + ", columna " + column
                                + ". Arreglo debe ser inicializado.");
                    } else {
                        this.temporalRow = new Row(node.hijos.get(i).value.toString(), this.type);
                        size = this.getTypeSize(this.type);
                        this.offset += size;
                        this.temporalRow.offset = this.offset;
                        this.getTableFromNode(this.node).list.add(temporalRow);
                        node.hijos.get(i).tableID = this.getTableFromNode(this.node).blockID;
                    }
                } else {
                    this.hasSemanticErrors = true;
                    System.out.println("Error semantico en linea " + line + ", columna " + column
                            + ". Variable " + node.hijos.get(i).value.toString() + " ya ha sido declarada.");
                }
            } else {
                evaluateAssignment(node.hijos.get(i), true);
            }
        }
    }

    public void evaluateAssignment(TreeNode node, boolean isDeclaration) {
        String id = node.getLefterSon().value.toString();
        TreeNode assignment = node.getHijos().get(1);
        String type = "";
        int size = 0;

        if (node.getParent().value.toString().equals("Declaration")) {
            if (isDeclaration) {
                if (!this.existInTable(this.node, id)) {
                    if (assignment.value.toString().equals("ArrayAssignment")) {
                        evaluateArrayDeclaration(assignment, node.getLefterSon(), isDeclaration);
                    } else if (assignment.value.toString().equals("Call")) {
                        if (this.evaluateCall(assignment, this.type, isDeclaration)) {
                            this.temporalRow = new Row(id, this.type);
                            size = this.getTypeSize(this.type);
                            this.offset += size;
                            this.temporalRow.offset = this.offset;
                            this.getTableFromNode(this.node).list.add(temporalRow);
                            node.getLefterSon().tableID = this.getTableFromNode(this.node).blockID;
                        } else {
                            this.hasSemanticErrors = true;
                            System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                                    + " Variable " + id + " es de tipo " + this.type);
                        }
                    } else {
                        type = this.getNodeType(assignment);
                        if (this.type.equals(type)) {
                            this.temporalRow = new Row(id, this.type);
                            size = this.getTypeSize(this.type);
                            this.offset += size;
                            this.temporalRow.offset = this.offset;
                            this.getTableFromNode(this.node).list.add(this.temporalRow);
                            node.getLefterSon().tableID = this.getTableFromNode(this.node).blockID;
                        } else {
                            this.hasSemanticErrors = true;
                            System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                                    + " Variable " + id + " es de tipo " + this.type);
                        }
                    }
                } else {
                    this.hasSemanticErrors = true;
                    System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                            + "Variable: " + id
                            + " ya ha sido declarada");
                }
            }
        } else {
            if (this.existInTable(this.node, id)) {
                int num = this.currentID;
                this.type = this.getTypeById(this.node, id);
                if (assignment.value.toString().equals("ArrayAssignment")) {
                    this.hasSemanticErrors = true;
                    System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                            + " Variable " + id + " no puede reasignarse");
                } else if (assignment.value.toString().equals("Call")) {
                    if (!this.evaluateCall(assignment, this.type, true)) {
                        this.hasSemanticErrors = true;
                        System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                                + " Variable " + id + " es de tipo " + this.type);
                    } else {
                        node.getLefterSon().tableID = num;
                    }
                } else {
                    type = this.getNodeType(assignment);
                    if (!this.type.equals(type)) {
                        this.hasSemanticErrors = true;
                        System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                                + " Variable " + id + " es de tipo " + this.type);
                    } else {
                        node.getLefterSon().tableID = this.currentID;
                    }
                }
            } else {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "Variable: " + id
                        + " no ha sido declarada");
            }
        }
    }

    public void evaluateArrayElementAssignment(TreeNode node) {
        String name = node.getLefterSon().value.toString();
        String type = "", varType = "";
        TreeNode assignment = node.getHijos().get(2);

        if (this.existInTable(this.node, name)) {
            int current = this.currentID;
            type = this.getTypeById(this.node, name);
            type = this.getArrayType(type);
            node.getLefterSon().tag = type;
            node.getLefterSon().tableID = current;
            this.isInteger = true;
            this.evaluateIntegers(null, node.getHijos().get(1));

            if (this.isInteger) {
                if (assignment.value.toString().equals("Call")) {
                    if (!this.evaluateCall(assignment, type, true)) {
                        this.hasSemanticErrors = true;
                        System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                                + "La variable " + name + " es de tipo " + type);
                    }
                } else {
                    varType = this.getNodeType(assignment);
                    if (!type.equals(varType)) {
                        this.hasSemanticErrors = true;
                        System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                                + "La variable " + name + " es de tipo " + type);
                    }
                }
            } else {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "La posicion del arreglo debe ser un entero");
            }
        } else {
            this.hasSemanticErrors = true;
            System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                    + "El arreglo " + name + " no existe.");
        }
    }

    public void evaluateArrayDeclaration(TreeNode node, TreeNode node2, boolean isDeclaration) {
        String id = node2.getValue().toString();
        String type = this.type;
        String size = "";
        line = node.line;
        column = node.column;
        if (node.getHijos().size() > 1) {
            this.type = node.getLefterSon().value.toString();
            if (type.contains(this.type)) {
                node = node.getHijos().get(1);
                this.isInteger = true;
                this.evaluateIntegers(null, node);
                if (isInteger) {
                    while (node.isParent()) {
                        node = node.getLefterSon();
                    }
                    size = node.value.toString();
                    int mySize = Integer.parseInt(size);
                    int typeSize = this.getTypeSize(this.type);
                    mySize *= typeSize;
                    this.type = this.getArrayType(this.type, size);
                    if (isDeclaration) {
                        this.offset += mySize;
                        this.getTableFromNode(this.node).list.add(new Row(id, this.type));
                        this.getTableFromNode(this.node).list
                                .get(this.getTableFromNode(this.node).list.size() - 1).offset = this.offset;
                        node2.tableID = this.getTableFromNode(this.node).blockID;
                    } else {
                        this.getRowById(this.node, id).setType(this.type);
                    }
                } else {
                    this.hasSemanticErrors = true;
                    System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                            + "El size del array debe ser un int");
                }
            } else {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + " La variable " + id + " es de tipo " + type);
            }
        } else {
            node = node.getLefterSon();
            this.type = this.getArrayType(this.type);
            if (!this.sameTypeElements(node, id)) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "Todos los elementos de " + id + " deben ser de tipo " + this.type.replace("[]", ""));
            } else {
                size = node.getHijos().size() + "";
                this.type = node.getHijos().get(0).value.toString();
                if (this.type.equals("Number")) {
                    this.type = "int";
                } else if (this.type.equals("variable")) {
                    this.type = this.getTypeById(this.node, node.getLefterSon().getLefterSon().value.toString());
                }
                this.type = this.getArrayType(this.type, size);
                if (isDeclaration) {
                    this.getTableFromNode(this.node).list.add(new Row(id, this.type));
                    node2.tableID = this.getTableFromNode(this.node).blockID;
                } else {
                    this.getRowById(this.node, id).setType(this.type);
                }
            }
        }
    }

    public void evaluateIntegers(TreeNode parent, TreeNode node) {
        if (!node.value.toString().equals("add") && !node.value.toString().equals("sub")
                && !node.value.toString().equals("mult") && !node.value.toString().equals("div")
                && !node.value.toString().equals("mod") && !node.value.toString().equals("Number")
                && !node.value.toString().equals("()")) {
            if (node.isParent()) {
                if (node.value.toString().equals("variable")) {
                    String id = node.getLefterSon().value.toString();
                    if (this.existInTable(this.node, id)) {
                        if (!this.getTypeById(this.node, id).equals("int")) {
                            this.isInteger = false;
                        } else {
                            node.tableID = this.currentID;
                            node.getLefterSon().tableID = this.currentID;
                        }
                    } else {
                        this.isInteger = false;
                    }
                } else if (node.value.toString().equals("ArrayElement")) {
                    String type = this.getArrayElementType(node);
                    node.getLefterSon().tag = type;

                    if (!type.equals("int")) {
                        this.isInteger = false;
                    }
                } else {
                    this.isInteger = false;
                    this.hasSemanticErrors = true;
                    System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                            + " Variable " + node.value.toString()
                            + " no ha sido declarada");
                }
            }
        }

        if (node.isParent()) {
            evaluateIntegers(node, node.getLefterSon());
        }

        if (node.hasRightBrother() && parent != null) {
            evaluateIntegers(parent, node.getRightBrother());
        }
    }

    public String getArrayElementType(TreeNode node) {
        String id = node.getHijos().get(0).value.toString();
        String type = "";

        if (this.existInTable(this.node, id)) {
            type = this.getTypeById(this.node, id);
            node.getHijos().get(0).tableID = this.currentID;
            if (type.contains("Array")) {
                type = this.getArrayType(type);
                this.isInteger = true;
                this.evaluateIntegers(null, node.getHijos().get(1));

                if (isInteger) {
                    return type;
                } else {
                    this.hasSemanticErrors = true;
                    System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                            + "El indice de " + id + " debe ser de tipo int");
                }
            } else {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "La variable " + id + " no es un arreglo");
            }
        } else {
            this.hasSemanticErrors = true;
            System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                    + "El arreglo " + id + " no ha sido declarado");
        }
        return "null";
    }

    public String getArrayType(String type) {
        String word = "";
        boolean copy = false;

        if (!type.contains("[]")) {
            for (int i = 0; i < type.length(); i++) {
                if (type.charAt(i) == ')') {
                    copy = false;
                }
                if (copy) {
                    word += type.charAt(i);
                }
                if (type.charAt(i) == ',') {
                    copy = true;
                }
            }
        }
        if (type.contains("[]")) {
            return type;
        }
        return word;
    }

    public boolean sameTypeElements(TreeNode node, String id) {
        String type = "";
        for (int i = 0; i < node.getHijos().size(); i++) {
            type = node.getHijos().get(i).value.toString();
            if (type.equals("Call")) {
                if (!this.evaluateCall(node.getHijos().get(i), this.type, true)) {
                    return false;
                }
            } else {
                type = this.getNodeType(node.getHijos().get(i));
                if (!this.type.contains(type)) {
                    return false;
                }
            }

        }
        return true;
    }

    public boolean evaluateCall(TreeNode node, String type, boolean verifyType) {
        line = node.line;
        column = node.column;
        String name = node.getLefterSon().value.toString();
        String params = "";
        ArrayList<Row> functions = new ArrayList();
        functions = ((SymbolTable) getLeftestSon(this.symbolTables.root).value).list;
        ArrayList<Row> functionsWithSameParameters = new ArrayList();
        boolean exist = existFunction(functions, name);

        if (exist) {
            functions = this.getItemsById(functions, name);
            params = this.getFunctionParams(node);
            functionsWithSameParameters = getFunctionsWithSameParameters(functions, params);

            if (verifyType) {
                if (this.verifyCallType(type, functionsWithSameParameters)) {
                    return true;
                }
            }
        }

        if (!exist) {
            this.hasSemanticErrors = true;
            System.out.println("Error semantico en linea " + line + ", columna " + column
                    + ". La funcion " + name + " no esta declarada");
        } else {
            if (functionsWithSameParameters.size() == 0) {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea " + line + ", columna " + column
                        + ". La funcion " + name + " no recibe esos parametros");
            }
        }

        return false;
    }

    public String getFunctionParams(TreeNode node) {
        String word = "", word2 = "";
        int size = ((TreeNode) node.getHijos().get(1)).getHijos().size();

        if (size > 0) {
            for (int i = 0; i < size; i++) {
                word2 = ((TreeNode) node.getHijos().get(1)).getHijos().get(i).value.toString();

                if (word2.equals("Call")) {
                    if (this.evaluateCall(((TreeNode) node.getHijos().get(1)).getHijos().get(i), "void", true)) {
                        word += this.actualType;
                    } else {
                        word = "intF";
                    }
                } else {
                    word += this.getNodeType(((TreeNode) node.getHijos().get(1)).getHijos().get(i));
                    ((TreeNode) node.getHijos().get(1)).getHijos().get(i).tableID = this.currentID;
                }

                if (i < size - 1) {
                    word += " x ";
                }
            }
        } else {
            word += "void";
        }
        return word;
    }

    public String getNodeType(TreeNode node) {
        String word = "intF";
        String id = "";
        String type = this.type;
        if (type.contains("Array")) {
            type = this.getArrayType(type);
        }

        if (node.value.toString().equals("variable")) {
            id = node.getLefterSon().value.toString();
            if (this.existInTable(this.node, id)) {
                word = this.getTypeById(this.node, id);
                if (word.equals("string")) {
                    if (id.length() == 1) {
                        word = "char";
                    }
                }
                node.tableID = this.currentID;
            } else {
                this.hasSemanticErrors = true;
                System.out.println("Error semantico en linea: " + line + ", columna: " + column + ". "
                        + "Variable " + id + " no ha sido declarada");
            }
        } else if (node.value.equals("()")) {
            word = this.getNodeType(node.getLefterSon());
        } else if (node.value.toString().equals("Number")) {
            word = "int";
        } else if (node.value.toString().equals("boolean")) {
            word = node.value.toString();
        } else if (node.value.toString().equals("string")) {
            String value = node.getLefterSon().value.toString();

            if (value.length() == 1) {
                word = "char";
            } else {
                word = "string";
            }
        } else if (node.value.toString().equals("add") || node.value.toString().equals("sub")
                || node.value.toString().equals("mult") || node.value.toString().equals("div")
                || node.value.toString().equals("mod") || node.value.toString().equals("()")) {
            this.isInteger = true;
            this.evaluateIntegers(null, node);

            if (this.isInteger) {
                word = "int";
            }
        } else if (node.value.toString().equals("ArrayElement")) {
            word = this.getArrayElementType(node);
            node.getLefterSon().tag = word;
        }
        return word;
    }

    public boolean verifyCallType(String type, ArrayList<Row> functions) {
        for (int i = 0; i < functions.size(); i++) {
            if (type.contains(this.getFunctionReturnType(functions.get(i).type))) {
                return true;
            }
        }

        if (type.equals("void")) {
            return true;
        }
        return false;
    }

    public String getFunctionReturnType(String type) {
        String returnType = "";
        boolean begin = false;

        for (int i = 0; i < type.length(); i++) {
            if (begin) {
                returnType += type.charAt(i);
            }

            if (type.charAt(i) == '>') {
                begin = true;
            }
        }
        this.actualType = returnType;
        return returnType;
    }

    public boolean existFunction(ArrayList<Row> list, String id) {
        for (int i = 0; i < list.size(); i++) {
            if (id.equals(list.get(i).id)) {
                return true;
            }
        }
        return false;
    }

    public ArrayList<Row> getFunctionsWithSameParameters(ArrayList<Row> functions, String params) {
        ArrayList<Row> list = new ArrayList();
        String word = "";
        int index = 0;

        for (int i = 0; i < functions.size(); i++) {
            while (functions.get(i).type.charAt(index) != '-') {
                word += functions.get(i).type.charAt(index);
                index++;
            }
            if (word.equals(params)) {
                list.add(functions.get(i));
            }
            word = "";
            index = 0;
        }
        return list;
    }

    public boolean existInTable(TreeNode node, String value) {
        while (node.getParent() != null) {
            for (int i = 0; i < this.getTableFromNode(node).list.size(); i++) {
                if (value.equals(this.getTableFromNode(node).list.get(i).id)) {
                    this.currentID = this.getTableFromNode(node).blockID;
                    return true;
                }
            }
            node = node.parent;
        }
        return false;
    }

    public Row getRowById(TreeNode node, String value) {
        while (node.getParent() != null) {
            for (int i = 0; i < this.getTableFromNode(node).list.size(); i++) {
                if (value.equals(this.getTableFromNode(node).list.get(i).id)) {
                    return this.getTableFromNode(node).list.get(i);
                }
            }
            node = node.parent;
        }
        return new Row("null", "null");
    }

    public String getTypeById(TreeNode node, String value) {
        while (node.getParent() != null) {
            for (int i = 0; i < this.getTableFromNode(node).list.size(); i++) {
                if (value.equals(this.getTableFromNode(node).list.get(i).id)) {
                    return this.getTableFromNode(node).list.get(i).getType();
                }
            }
            node = node.parent;
        }
        return "null";
    }

    public TreeNode getLeftestSon(TreeNode node) {
        while (node.isParent()) {
            node = node.getLefterSon();
        }
        return node;
    }

    public ArrayList<Row> getItemsById(ArrayList<Row> list, String id) {
        ArrayList<Row> items = new ArrayList();

        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).id.equals(id)) {
                items.add(list.get(i));
            }
        }
        return items;
    }

    public String getArrayType(String type, String size) {
        String arrayType = "";
        arrayType = "Array(0..." + (Integer.parseInt(size) - 1) + "," + type + ")";
        return arrayType;
    }

    public void showTree(TreeNode parent, TreeNode node, DefaultTreeModel model, DefaultMutableTreeNode treeNode) {
        if (parent == null) {
            model = new DefaultTreeModel(new DefaultMutableTreeNode(node.getValue()));
            if (node.hijos.size() > 0) {
                showTree(node, node.getLefterSon(), model, (DefaultMutableTreeNode) model.getRoot());
            }
        } else {
            DefaultMutableTreeNode hijo = new DefaultMutableTreeNode(node.getValue());
            treeNode.add(hijo);
            if (node.hasRightBrother()) {
                showTree(parent, node.getRightBrother(), model, treeNode);
            }

            if (node.hijos.size() > 0) {
                showTree(node, node.getLefterSon(), model, hijo);
            }
        }
        this.jTree1.setModel(model);
    }
//************************************************************************************************************

    public void inspectTree(TreeNode parent, TreeNode node) {
        if (!this.finishedInspection) {
            //System.out.println(node.value);
            generateICode(node);
            if (node.hasRightBrother()) {
                node = node.getRightBrother();
                this.generateFunctionICode(node);
                node = this.getLeftestSon(node);
                inspectTree(node.parent, node);
            }

            if (!parent.value.toString().equals("Program")) {
                inspectTree(parent.parent, parent);
            } else {
                this.finishedInspection = true;
            }
        }
    }

    public void generateFunctionICode(TreeNode node) {
        String name = "";
        TreeNode params = new TreeNode();

        if (node.value.equals("Functions")) {
            name = node.getLefterSon().getLefterSon().value.toString();
            params = node.getLefterSon().hijos.get(2);
            this.cuadruplos.list.add(new RowIntermediate("F_ETIQ2", this.currentF_ETIQ, "", ""));
            this.cuadruplos.list.add(new RowIntermediate("F_ETIQ", name, params.hijos.size() + "", ""));
            this.currentF_ETIQ = name;
        } else if (node.value.equals("function")) {
            name = node.getLefterSon().value.toString();
            params = node.getHijos().get(2);
            this.cuadruplos.list.add(new RowIntermediate("F_ETIQ2", this.currentF_ETIQ, "", ""));
            this.cuadruplos.list.add(new RowIntermediate("F_ETIQ", name, params.hijos.size() + "", ""));
            this.currentF_ETIQ = name;
        }
    }

    public void generateICode(TreeNode node) {
        if (node.value.toString().equals("Number") || node.value.toString().equals("variable")
                || node.value.toString().equals("boolean") || node.value.toString().equals("string")) {
            if (node.hijos.size() > 0) {
                node.tag = node.getLefterSon().value.toString();
                //node.tableID = node.getLefterSon().tableID;
            }
        } else if (node.value.toString().equals("()")) {
            node.tag = node.getLefterSon().tag;
        } else if (node.value.toString().equals("add")) {
            this.generateMathICode(node, "+");
        } else if (node.value.toString().equals("sub")) {
            this.generateMathICode(node, "-");
        } else if (node.value.toString().equals("mult")) {
            this.generateMathICode(node, "*");
        } else if (node.value.toString().equals("div")) {
            this.generateMathICode(node, "/");
        } else if (node.value.toString().equals("mod")) {
            this.generateMathICode(node, "mod");
        } else if (node.value.toString().equals("Assignment")) {
            this.generateAssignmentICode(node, ":=");
        } else if (node.value.toString().equals("ArrayElement")) {
            this.generateArrayElementICode(node);
        } else if (node.value.toString().equals("ArrayElementAssignment")) {
            this.generateArrayElementAssignentICode(node);
        } else if (node.value.toString().equals("Equal") || node.value.toString().equals("GreaterEqual")
                || node.value.toString().equals("LessThan") || node.value.toString().equals("LessEqual")
                || node.value.toString().equals("GreaterThan") || node.value.toString().equals("Different")) {
            int num1 = node.getLefterSon().tableID;
            int num2 = node.getLefterSon().getRightBrother().tableID;
            node.tableID = this.getGreater(num1, num2);
            this.generateBooleanExpressionICode(node);
            if (node.hasRightBrother()) {
                if (node.getRightBrother().hasRightBrother()) {
                    if (node.getRightBrother().getRightBrother().value.equals("Else")) {
                        System.out.println("Falsa: " + node.falsa);
                        node.getRightBrother().getRightBrother().falsa = node.falsa;
                    }
                }
            }
        } else if (node.value.toString().equals("If")) {
            this.cuadruplos.list.add(new RowIntermediate("GOTO", node.siguiente, "", ""));
            if (!((TreeNode) node.getHijos().get(node.getHijos().size() - 1)).value.toString().equals("Else")) {
                this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.falsa, "", ""));
            }
            this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.siguiente, "", ""));
        } else if (node.value.toString().equals("ElseIf")) {
            node.parent.falsa = node.falsa;
            if (node.hasRightBrother()) {
                if (node.getRightBrother().value.toString().equals("Else")) {
                    node.getRightBrother().falsa = node.falsa;
                }
            }
        } else if (node.value.toString().equals("Else")) {
            //*****************************************************
        } else if (node.value.toString().equals("AND") || node.value.toString().equals("OR")) {
            int num1 = node.getLefterSon().tableID;
            int num2 = node.getLefterSon().getRightBrother().tableID;
            node.tableID = this.getGreater(num1, num2);
            this.generateAndICode(node);
            if (node.hasRightBrother()) {
                if (node.getRightBrother().hasRightBrother()) {
                    if (node.getRightBrother().getRightBrother().value.equals("Else")) {
                        System.out.println("Falsa: " + node.falsa);
                        node.getRightBrother().getRightBrother().falsa = node.falsa;
                    }
                }
            }
        } else if (node.value.toString().equals("While")) {
            this.cuadruplos.list.add(new RowIntermediate("GOTO", node.primero, "", ""));
            this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.falsa, "", ""));
        } else if (node.value.toString().equals("ForVariable")) {
            node.tag = node.getLefterSon().getRightBrother().value.toString();
        } else if (node.value.toString().equals("Range")) {
            node.primero = node.getLefterSon().tag;
            node.siguiente = node.getLefterSon().getRightBrother().tag;
        } else if (node.value.toString().equals("StepValue")) {
            node.tag = node.getLefterSon().tag;
        } else if (node.value.toString().equals("Condition")) {
            this.generateForConditionICode(node);
        } else if (node.value.toString().equals("For")) {
            this.generateForICode(node);
        } else if (node.value.toString().equals("SwitchVariable")) {
            node.tag = node.getLefterSon().value.toString();
            node.siguiente = this.cuadruplos.etiqNuevo();
            node.parent.siguiente = node.siguiente;
        } else if (node.value.toString().equals("CaseVariable")) {
            this.generateCaseVariableICode(node);
        } else if (node.value.toString().equals("Case")) {
            node.siguiente = node.parent.siguiente;
            node.falsa = node.getLefterSon().falsa;
            this.cuadruplos.list.add(new RowIntermediate("GOTO", node.siguiente, "", ""));
            this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.falsa, "", ""));
        } else if (node.value.toString().equals("ElseCondition")) {
            this.cuadruplos.list.add(new RowIntermediate("GOTO", node.parent.parent.siguiente, "", ""));
            this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.parent.falsa, "", ""));
        } else if (node.value.toString().equals("FunctionParams")) {
            node.tag = node.hijos.size() + "";
            String type = "", value = "";
            for (int i = 0; i < node.hijos.size(); i++) {
                value = node.hijos.get(i).tag;
                type = node.hijos.get(i).value.toString();
                if (type.equals("string")) {
                    if (value.length() == 1) {
                        type = "char";
                    }
                }
                this.cuadruplos.list.add(new RowIntermediate("param", value, type, ""));
                this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = node.hijos.get(i).tableID;
            }
        } else if (node.value.toString().equals("Call")) {
            node.tag = this.cuadruplos.tempNuevo();
            String name = node.getLefterSon().value.toString();
            String params = node.getLefterSon().getRightBrother().tag;
            this.cuadruplos.list.add(new RowIntermediate("call", name, params, node.tag));
        } else if (node.value.toString().equals("Return")) {
            String value = node.getLefterSon().tag;
            String type = node.getLefterSon().value.toString();
            if (type.equals("string")) {
                if (value.length() == 1) {
                    type = "char";
                }
            }
            this.cuadruplos.list.add(new RowIntermediate("RETURN", value, type, ""));
            this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = node.getLefterSon().tableID;
        } else if (node.value.toString().equals("Read")) {
            String value = node.getLefterSon().value.toString();
            int tableID = node.getLefterSon().tableID;
            this.getTableByID(this.symbolTables.root, this.symbolTables.root.getLefterSon(), tableID);
            String type = this.getTypeById(this.node, value);
            this.cuadruplos.list.add(new RowIntermediate("READ", value, type, ""));
            this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = tableID;
        } else if (node.value.toString().equals("Write")) {
            String value = "";
            String type = "";
            int id = 0;

            for (int i = 0; i < node.getHijos().size(); i++) {
                id = 0;
                id = node.getHijos().get(i).tableID;
                value = node.getHijos().get(i).tag;
                type = node.getHijos().get(i).value.toString();
                if (type.equals("string")) {
                    if (value.length() == 1) {
                        type = "char";
                    }
                }
                this.cuadruplos.list.add(new RowIntermediate("WRITE", value, type, ""));
                this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = id;
            }
        }
    }

    public void generateMathICode(TreeNode node, String symbol) {
        String arg1 = node.getHijos().get(0).tag;
        String arg2 = node.getHijos().get(1).tag;
        int table1 = node.getHijos().get(0).tableID;
        int table2 = node.getHijos().get(1).tableID;
        int table = 0;

        if (table1 > table2) {
            table = table1;
        } else {
            table = table2;
        }
        if (this.isDigit(arg1) && this.isDigit(arg2)) {
            int num1 = Integer.parseInt(arg1);
            int num2 = Integer.parseInt(arg2);
            this.tag = this.returnValue(num1, num2, symbol) + "";
        } else {
            this.tag = this.cuadruplos.tempNuevo();
            this.cuadruplos.list.add(new RowIntermediate(symbol, arg1, arg2, this.tag));
            this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = table;
        }
        node.tag = this.tag;
    }

    public void generateAssignmentICode(TreeNode node, String symbol) {
        String assignment = node.getHijos().get(1).value.toString();
        String type = "";

        if (!assignment.equals("ArrayAssignment")) {
            String arg1 = node.getHijos().get(1).tag;
            int assignmentPosition = node.getHijos().get(1).tableID;
            int myPosition = node.getLefterSon().tableID;
            int tableID = this.getGreater(assignmentPosition, myPosition);
            this.tag = node.getLefterSon().value.toString();
            node.tag = this.tag;
            this.cuadruplos.list.add(new RowIntermediate(symbol, arg1, assignment, this.tag));
            this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = tableID;
        }
    }

    public void generateArrayElementICode(TreeNode node) {
        String name = node.getLefterSon().value.toString();
        String type = node.getLefterSon().tag;
        int typeSize = this.getTypeSize(type);
        String index = node.getHijos().get(1).tag;
        String temporal = "";
        int nameIndex = node.getLefterSon().tableID;
        int indexIndex = node.getHijos().get(1).tableID;

        int index1 = this.getGreater(nameIndex, indexIndex);
        this.tag = this.cuadruplos.tempNuevo();
        if (isDigit(index)) {
            this.tag = this.returnValue(typeSize, Integer.parseInt(index), "*") + "";
        } else {
            this.cuadruplos.list.add(new RowIntermediate("*", typeSize + "", index, this.tag));
            this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = index1;
        }

        temporal = this.cuadruplos.tempNuevo();
        this.cuadruplos.list.add(new RowIntermediate("=[]", name, this.tag, temporal));
        this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = index1;
        node.tag = temporal;
    }

    public void generateArrayElementAssignentICode(TreeNode node) {
        String type = node.getLefterSon().tag;
        int typeSize = this.getTypeSize(type);
        String index = node.getHijos().get(1).tag;
        String name = node.getLefterSon().value.toString();
        String assignment = node.getHijos().get(2).tag;

        int indexTable = node.getHijos().get(1).tableID;
        int nameTable = node.getLefterSon().tableID;
        int assignmentTable = node.getHijos().get(2).tableID;
        int tableID = this.getGreater(indexTable, nameTable);
        tableID = this.getGreater(tableID, assignmentTable);

        if (isDigit(index)) {
            this.tag = this.returnValue(typeSize, Integer.parseInt(index), "*") + "";
        } else {
            this.tag = this.cuadruplos.tempNuevo();
            this.cuadruplos.list.add(new RowIntermediate("*", typeSize + "", index, this.tag));
            this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = tableID;
        }

        this.cuadruplos.list.add(new RowIntermediate("[]=", this.tag, assignment, name));
        this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = tableID;
    }

    public void generateBooleanExpressionICode(TreeNode node) {
        if (!node.parent.value.equals("AND") && !node.parent.value.equals("OR")) {
            this.generateSingleBooleanExpressionICode(node);
        } else if (node.parent.value.toString().equals("AND") || node.parent.value.toString().equals("OR")) {
            generateSingleAndICode(node);
        }
    }

    public void generateSingleBooleanExpressionICode(TreeNode node) {
        String symbol = this.getRelationalOperator(node.value.toString());
        String leftVal = node.getLefterSon().tag;
        String rightVal = node.getLefterSon().getRightBrother().tag;

        node.verdadera = this.cuadruplos.etiqNuevo();
        node.falsa = this.cuadruplos.etiqNuevo();
        node.parent.falsa = node.falsa;
        node.siguiente = this.cuadruplos.etiqNuevo();

        if (node.parent.value.toString().equals("ElseIf")) {
            node.parent.siguiente = node.parent.parent.siguiente;
            node.parent.falsa = node.parent.parent.falsa;
            node.parent.parent.falsa = node.falsa;
            this.cuadruplos.list.add(new RowIntermediate("GOTO", node.parent.siguiente, "", ""));
            this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.parent.falsa, "", ""));
            node.parent.falsa = node.falsa;
        } else if (node.parent.value.toString().equals("If")) {
            node.parent.siguiente = node.siguiente;
        } else if (node.parent.value.toString().equals("While")) {
            node.primero = this.cuadruplos.etiqNuevo();
            node.parent.primero = node.primero;
            node.parent.falsa = node.falsa;
            this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.primero, "", ""));
        }

        this.createIf(leftVal, rightVal, node.verdadera, node.falsa, symbol, node.getLefterSon(),
                node.getLefterSon().getRightBrother());
        this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.verdadera, "", ""));
    }

    public void generateSingleAndICode(TreeNode node) {
        String symbol = this.getRelationalOperator(node.value.toString());
        String leftVal = node.getLefterSon().tag;
        String rightVal = node.getLefterSon().getRightBrother().tag;
        TreeNode parent = this.getParentNode(node);
        boolean isFirst = this.isFirstBooleanExpression(parent, this.getLeftestSon(node));

        if (node.parent.getLefterSon().equals(node)) {
            if (isFirst) {
                if (parent.value.toString().equals("ElseIf")) {
                    this.cuadruplos.list.add(new RowIntermediate("GOTO", parent.parent.siguiente, "", ""));
                    this.cuadruplos.list.add(new RowIntermediate("ETIQ", parent.parent.falsa, "", ""));
                } else if (parent.value.toString().equals("While")) {
                    node.primero = this.cuadruplos.etiqNuevo();
                    parent.primero = node.primero;
                    this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.primero, "", ""));
                }
                node.siguiente = this.cuadruplos.etiqNuevo();
            }

            node.verdadera = this.cuadruplos.etiqNuevo();
            node.falsa = this.cuadruplos.etiqNuevo();
            this.createIf(leftVal, rightVal, node.verdadera, node.falsa, symbol,
                    node.getLefterSon(), node.getLefterSon().getRightBrother());
            if (node.parent.value.toString().equals("AND")) {
                this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.verdadera, "", ""));
            } else if (node.parent.value.toString().equals("OR")) {
                this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.falsa, "", ""));
            }
        } else {
            if (node.parent.value.toString().equals("AND")) {
                node.verdadera = this.cuadruplos.etiqNuevo();
                node.falsa = node.parent.getLefterSon().falsa;
            } else if (node.parent.value.toString().equals("OR")) {
                node.verdadera = node.parent.getLefterSon().verdadera;
                node.falsa = this.cuadruplos.etiqNuevo();
            }
            node.primero = leftVal;
            node.siguiente = rightVal;
            node.tag = symbol;
        }
    }

    public void generateAndICode(TreeNode node) {
        String leftVal = "", rightVal = "", symbol = "";
        node.verdadera = node.getLefterSon().getRightBrother().verdadera;
        node.falsa = node.getLefterSon().getRightBrother().falsa;
        node.siguiente = node.getLefterSon().siguiente;
        leftVal = node.getLefterSon().getRightBrother().primero;
        rightVal = node.getLefterSon().getRightBrother().siguiente;
        symbol = node.getLefterSon().getRightBrother().tag;

        if (!node.parent.value.toString().equals("AND") && !node.parent.value.toString().equals("OR")) {
            node.parent.siguiente = node.siguiente;
            node.parent.falsa = node.falsa;
            this.createIf(leftVal, rightVal, node.verdadera, node.falsa, symbol,
                    node.getLefterSon(), node.getLefterSon().getRightBrother());
            this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.verdadera, "", ""));
        } else {
            if (node.parent.getLefterSon().equals(node)) {
                this.createIf(leftVal, rightVal, node.verdadera, node.falsa, symbol,
                        node.getLefterSon(), node.getLefterSon().getRightBrother());
                if (node.parent.value.toString().equals("OR")) {
                    this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.falsa, "", ""));
                } else if (node.parent.value.toString().equals("AND")) {
                    this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.falsa, "", ""));
                }
            } else {
                if (node.parent.value.toString().equals("OR")) {
                    node.verdadera = node.parent.getLefterSon().verdadera;
                    node.falsa = node.getLefterSon().getRightBrother().falsa;
                } else if (node.parent.value.toString().equals("AND")) {
                    node.verdadera = node.getLefterSon().getRightBrother().verdadera;
                    node.falsa = node.parent.getLefterSon().falsa;
                }
                node.primero = leftVal;
                node.siguiente = rightVal;
                node.tag = symbol;
            }
        }
    }

    public void generateForConditionICode(TreeNode node) {
        String variable = node.getLefterSon().tag;
        String firstValue = node.getLefterSon().getRightBrother().primero;
        String lastValue = node.getLefterSon().getRightBrother().siguiente;
        String stepValue = node.getLefterSon().getRightBrother().getRightBrother().tag;
        node.primero = this.cuadruplos.etiqNuevo();
        node.verdadera = this.cuadruplos.etiqNuevo();
        node.falsa = this.cuadruplos.etiqNuevo();
        node.siguiente = stepValue;

        this.cuadruplos.list.add(new RowIntermediate(":=", firstValue, "", variable));
        this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = node.getLefterSon().tableID;
        this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.primero, "", ""));
        this.createIf(variable, lastValue, node.verdadera, node.falsa, "<=",
                node.getLefterSon(), node.getLefterSon().getRightBrother());
        this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.verdadera, "", ""));
        node.verdadera = variable;
    }

    public void generateForICode(TreeNode node) {
        node.primero = node.getLefterSon().primero;
        node.falsa = node.getLefterSon().falsa;
        node.siguiente = this.cuadruplos.tempNuevo();
        String variable = node.getLefterSon().verdadera;
        String stepValue = node.getLefterSon().siguiente;
        int symbolId = node.getLefterSon().getLefterSon().tableID;

        this.cuadruplos.list.add(new RowIntermediate("+", variable, stepValue, node.siguiente));
        this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = symbolId;
        this.cuadruplos.list.add(new RowIntermediate(":=", node.siguiente, "", variable));
        this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = symbolId;
        this.cuadruplos.list.add(new RowIntermediate("GOTO", node.primero, "", ""));
        this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.falsa, "", ""));
    }

    public void generateCaseVariableICode(TreeNode node) {
        int myPosition = node.parent.getMyPoistion();
        node.tag = node.parent.parent.getHijos().get(myPosition - 1).tag;
        String value = node.getLefterSon().value.toString();

        if (!value.equals("default")) {
            node.verdadera = this.cuadruplos.etiqNuevo();
            node.falsa = this.cuadruplos.etiqNuevo();

            this.createIf(node.tag, value, node.verdadera, node.falsa, "==",
                    node.parent.parent.getHijos().get(myPosition - 1), node.getLefterSon());
            this.cuadruplos.list.add(new RowIntermediate("ETIQ", node.verdadera, "", ""));
        } else {
            node.falsa = node.parent.parent.siguiente;
        }

    }

    public void createIf(String left, String right, String verdadero, String falso, String symbol,
        TreeNode leftNode, TreeNode rightNode) {
        int leftVal = leftNode.tableID;
        int rightVal = rightNode.tableID;
        int val = this.getGreater(leftVal, rightVal);

        if (leftNode.value.toString().equals("string")) {
            left = "\'" + left + "\'";
        }

        if (rightNode.value.toString().equals("string")) {
            right = "\'" + right + "\'";
        }
        System.out.println("Left: " + leftNode.value);
        System.out.println("Right: " + rightNode.value);
        this.cuadruplos.list.add(new RowIntermediate("if " + symbol, left, right, verdadero));
        this.cuadruplos.list.get(this.cuadruplos.list.size() - 1).table = val;
        this.cuadruplos.list.add(new RowIntermediate("GOTO", falso, "", ""));
    }

    public boolean isAndOrOr(TreeNode node){
        if(node.value.toString().equals("LessEqual") || node.value.toString().equals("GreaterEqual") || 
                node.value.toString().equals("Different") || node.value.toString().equals("Equal") || 
                node.value.toString().equals("LessThan") || node.value.toString().equals("GreaterThan")){
            return true;
        }
        return false;
    }
    public TreeNode getParentNode(TreeNode node) {
        while (node.value.toString().equals("AND") || node.value.toString().equals("OR")
                || node.value.toString().equals("GreaterThan") || node.value.toString().equals("LessThan")
                || node.value.toString().equals("LessEqual") || node.value.toString().equals("GreaterEqual")
                || node.value.toString().equals("Equal") || node.value.toString().equals("Different")) {
            node = node.getParent();
        }
        return node;
    }

    public boolean isFirstBooleanExpression(TreeNode parent, TreeNode node) {
        if (node.equals(this.getLeftestSon(parent))) {
            return true;
        }
        return false;
    }

    public int returnValue(int num1, int num2, String operator) {
        if (operator.equals("+")) {
            return num1 + num2;
        } else if (operator.equals("-")) {
            return num1 - num2;
        } else if (operator.equals("*")) {
            return num1 * num2;
        } else if (operator.equals("/")) {
            return num1 / num2;
        }
        return -1;
    }

    public int getTypeSize(String type) {
        if (type.equals("int")) {
            return 4;
        } else if (type.equals("boolean")) {
            return 4;
        } else if (type.equals("char")) {
            return 4;
        } else if (type.equals("stirng")) {
            return -2;
        }

        return -1;
    }

    public boolean isDigit(String word) {
        for (int i = 0; i < word.length(); i++) {
            if (!Character.isDigit(word.charAt(i))) {
                if (i == 0) {
                    if (word.charAt(i) != '-') {
                        return false;
                    }
                } else {
                    return false;
                }
            }
        }
        return true;
    }

    public int getGreater(int a, int b) {
        if (a > b) {
            return a;
        }
        return b;
    }

    public String getRelationalOperator(String type) {
        if (type.equals("Equal")) {
            return "==";
        } else if (type.equals("Different")) {
            return "!=";
        } else if (type.equals("LessThan")) {
            return "<";
        } else if (type.equals("GreaterThan")) {
            return ">";
        } else if (type.equals("GreaterEqual")) {
            return ">=";
        } else if (type.equals("LessEqual")) {
            return "<=";
        }
        return "";
    }

    public void showCuadruplos() {
        DefaultTableModel model = new DefaultTableModel();
        model.addColumn("Operador");
        model.addColumn("Arg1");
        model.addColumn("Arg2");
        model.addColumn("Temporal");
        String[] arr = new String[4];

        for (int i = 0; i < this.cuadruplos.list.size(); i++) {
            arr[0] = this.cuadruplos.list.get(i).getOperator();
            arr[1] = this.cuadruplos.list.get(i).getArg1();
            arr[2] = this.cuadruplos.list.get(i).getArg2();
            arr[3] = this.cuadruplos.list.get(i).getResult();
            model.addRow(arr);
        }

        this.tablaCuadruplos.setModel(model);
        this.jDialog1.pack();
        this.jDialog1.setVisible(true);
    }

    public void getTableByID(TreeNode parent, TreeNode node, int id) {

        if (this.getTableFromNode(node).blockID == id) {
            this.node = node;
        }

        if (node.isParent()) {
            getTableByID(node, node.getLefterSon(), id);
        }

        if (node.hasRightBrother()) {
            getTableByID(parent, node.getRightBrother(), id);
        }
    }

    //***********************************************************************************************
    public void generateFinalCode() {
        RowIntermediate row = new RowIntermediate();
        this.data += "_nextLine: .asciiz \"\\n\"\n";
        this.body += "move $fp,$sp\n";
        this.body += "jal _main\n";

        for (int i = 0; i < this.cuadruplos.list.size(); i++) {
            row = this.cuadruplos.list.get(i);
            if (row.operator.equals("F_ETIQ")) {
                this.generateF_ETIQFinalCode(row.arg1, row.arg2);
            } else if (row.operator.equals(":=")) {
                this.generateAssignmentFinalCode(row.arg1, row.arg2, row.result, row.table);
            } else if (row.operator.equals("WRITE")) {
                this.generateWriteFinalCode(row.arg1, row.arg2, row.table);
            } else if (row.operator.equals("+") || row.operator.equals("-")
                    || row.operator.equals("*") || row.operator.equals("/")) {
                this.generateAdditionFinalCode(row.arg1, row.arg2, row.result, row.table, row.operator);
            } else if (row.operator.equals("if ==")) {
                this.generateComparisonFinalCode(row.arg1, row.arg2, row.result, row.table, "==");
            } else if (row.operator.equals("if !=")) {
                this.generateComparisonFinalCode(row.arg1, row.arg2, row.result, row.table, "!=");
            } else if (row.operator.equals("if >=")) {
                this.generateComparisonFinalCode(row.arg1, row.arg2, row.result, row.table, ">=");
            } else if (row.operator.equals("if <=")) {
                this.generateComparisonFinalCode(row.arg1, row.arg2, row.result, row.table, "<=");
            } else if (row.operator.equals("if >")) {
                this.generateComparisonFinalCode(row.arg1, row.arg2, row.result, row.table, ">");
            } else if (row.operator.equals("if <")) {
                this.generateComparisonFinalCode(row.arg1, row.arg2, row.result, row.table, "<");
            } else if (row.operator.equals("GOTO")) {
                this.body += "b _" + row.arg1 + "\n";
            } else if (row.operator.equals("ETIQ")) {
                this.body += "_" + row.arg1 + ":\n";
            } else if (row.operator.equals("READ")) {
                this.generateReadFinalCode(row.arg1, row.arg2, row.table);
            } else if (row.operator.equals("param")) {
                this.generateParamFinalCode(row.arg1, row.arg2, row.table);
            } else if (row.operator.equals("call")) {
                this.generateCallFinalCode(row.arg1, row.result);
            } else if (row.operator.equals("F_ETIQ2")) {
                this.generateF_ETIQ2FinalCode(row.arg1);
            } else if (row.operator.equals("RETURN")) {
                this.generateReturnFinalCode(row.arg1, row.arg2, row.table);
            } else if (row.operator.equals("[]=")) {
                this.assignToArrayFinalCode(row.result, row.arg1, row.arg2, row.table);
            } else if (row.operator.equals("=[]")) {
                this.assignArrayToFinalCode(row.result, row.arg1, row.arg2, row.table);
            }
        }

        System.out.println(this.body + this.data);
    }

    public void assignArrayToFinalCode(String temp, String arr, String index, int tableRef) {
        int pos = this.getPositionInStack(arr, tableRef);
        String type = this.temporalRow.type;

        if (this.isDigit(index)) {
            this.body += "li $t8, " + index + "\n";
            this.body += "add $t9,$t8," + pos + "\n";
        } else if (this.isTemporal(index)) {
            this.body += "add $t9,$" + index + "," + pos + "\n";
        }

        this.body += "move $sp,$fp\n";
        this.body += "add $fp,$fp,$t9\n";
        if (type.contains("int")) {
            this.body += "lw $" + temp + ",($fp)\n";
        } else if (type.contains("char") || type.contains("boolean")) {
            this.body += "lb $" + temp + ",($fp)\n";
        }
        this.body += "lw $fp,-4($sp)\n";
    }

    public void assignToArrayFinalCode(String arr, String index, String value, int tableRef) {
        int pos = this.getPositionInStack(arr, tableRef);
        String type2 = this.temporalRow.type;
        if (this.isDigit(index)) {
            this.body += "li $t8, " + index + "\n";
            this.body += "add $t9,$t8," + pos + "\n";
        } else if (this.isTemporal(index)) {
            this.body += "add $t9,$" + index + "," + pos + "\n";
        }
        this.body += "move $sp,$fp\n";
        if (this.isDigit(value)) {
            this.body += "add $fp,$fp,$t9\n";
            this.body += "li $t8," + value + "\n";
            this.body += "sw $t8,($fp)\n";
        } else if (this.isTemporal(value)) {
            this.body += "add $fp,$fp,$t9\n";
            if (type2.contains("int")) {
                this.body += "sw $" + value + ",($fp)\n";
            } else if (type2.contains("char") || type2.contains("boolean")) {
                this.body += "sb $" + value + ",($fp)\n";
            }
        } else {
            int pos2 = this.getPositionInStack(value, tableRef);
            String type = this.temporalRow.type;

            if (type.equals("int")) {
                this.body += "lw $t8," + pos2 + "($fp)\n";
            } else if (type.equals("char") || type.equals("boolean")) {
                this.body += "lb $t8," + pos2 + "($fp)\n";
            }
            this.body += "add $fp,$fp,$t9\n";
            this.body += "sw $t8,($fp)\n";
        }
        this.body += "lw $fp,-4($sp)\n";
    }

    public void generateReturnFinalCode(String arg1, String arg2, int tableRef) {
        if (arg2.equals("variable")) {
            int stackPos = this.getPositionInStack(arg1, tableRef);
            String type = this.temporalRow.type;

            if (type.equals("int")) {
                this.body += "lw $v0," + stackPos + "($fp)\n";
            this.body += "b _" + this.currentFunction + "Salida" + "\n";
            } else if (type.equals("boolean")) {
                this.body += "lb $v0," + stackPos + "($fp)\n";
            this.body += "b _" + this.currentFunction + "Salida" + "\n";
            } else if (type.equals("char")) {
                this.body += "lb $v0," + stackPos + "($fp)\n";
            this.body += "b _" + this.currentFunction + "Salida" + "\n";
            }
        } else if (arg2.equals("Number")) {
            this.body += "li $v0," + arg1 + "\n";
            this.body += "b _" + this.currentFunction + "Salida" + "\n";
        } else if (arg2.equals("boolean")) {
            arg1 = this.booleanToByte(arg1) + "";
            this.body += "li $v0," + arg1 + "\n";
            this.body += "b _" + this.currentFunction + "Salida" + "\n";
        } else if (arg2.equals("char")) {
            this.body += "li $v0,\'" + arg1 + "\'\n";
            this.body += "b _" + this.currentFunction + "Salida" + "\n";
        } else if (arg2.equals("add") || arg2.equals("sub") || arg2.equals("mult") || arg2.equals("div")
                || arg2.equals("()")) {
            this.body += "move $v0,$" + arg1 + "\n";
            this.body += "b _" + this.currentFunction + "Salida" + "\n";
        } else if (this.isTemporal(arg1)) {
            this.body += "move $v0,$" + arg1 + "\n";
            this.body += "b _" + this.currentFunction + "Salida" + "\n";
        }
    }

    public void generateCallFinalCode(String name, String temp) {
        int pos = this.getPositionInStack(name, 0);
        String type = this.temporalRow.type;
        type = this.getFunctionReturnType(type);

        this.body += "add $sp,$sp," + (this.lastOffset) + "\n";
        this.body += "jal _" + name + "\n";
        this.body += "move $sp,$fp\n";
        if (type.equals("int")) {
            this.body += "move $" + temp + ",$v0\n";
        } else if (type.equals("char")) {
            this.body += "move $" + temp + ",$v0\n";
        } else if (type.equals("boolean")) {
            this.body += "move $" + temp + ",$v0\n";
        }

        this.paramCounter = 0;
    }

    public void generateParamFinalCode(String arg1, String arg2, int tableRef) {
        if (this.paramCounter < 4) {
            if (arg2.equals("variable")) {
                int pos = this.getPositionInStack(arg1, tableRef);
                String type = this.temporalRow.type;

                if (type.equals("int")) {
                    this.body += "lw $a" + this.paramCounter + "," + pos + "($fp)\n";
                    this.paramCounter++;
                } else if (type.equals("char")) {
                    this.body += "lb $a" + this.paramCounter + "," + pos + "($fp)\n";
                    this.paramCounter++;
                } else if (type.equals("boolean")) {
                    this.body += "lb $a" + this.paramCounter + "," + pos + "($fp)\n";
                    this.paramCounter++;
                }
            } else if (arg2.equals("Number")) {
                this.body += "li $a" + this.paramCounter + "," + arg1 + "\n";
                this.paramCounter++;
            } else if (arg2.equals("boolean")) {
                arg1 = this.booleanToByte(arg1) + "";
                this.body += "li $a" + this.paramCounter + "," + arg1 + "\n";
                this.paramCounter++;
            } else if (arg2.equals("char")) {
                this.body += "li $a" + this.paramCounter + ",\'" + arg1 + "\'\n";
                this.paramCounter++;
            } else if (arg2.equals("add") || arg2.equals("sub") || arg2.equals("mult") || arg2.equals("div")
                    || arg2.equals("()")) {
                this.body += "move $a" + this.paramCounter + ",$" + arg1 + "\n";
                this.paramCounter++;
            } else if (this.isTemporal(arg1)) {
                this.body += "move $a" + this.paramCounter + ",$" + arg1 + "\n";
                this.paramCounter++;
            }
        }
    }

    public void generateReadFinalCode(String arg1, String type, int tableRef) {
        int stackPosition = this.getPositionInStack(arg1, tableRef);

        if (type.equals("int")) {
            this.body += "li $v0,5\n";
            this.body += "syscall\n";
            this.body += "sw $v0," + stackPosition + "($fp)\n";
        } else if (type.equals("char")) {
            this.body += "li $v0,12\n";
            this.body += "syscall\n";
            this.body += "sb $v0," + stackPosition + "($fp)\n";
        }
    }

    public void generateComparisonFinalCode(String arg1, String arg2, String etiq, int tableRef, String symbol) {
        arg1 = this.getFinalValue("$t9", arg1, tableRef);
        arg2 = this.getFinalValue("$t8", arg2, tableRef);

        if (symbol.equals("==")) {
            this.body += "beq " + arg1 + "," + arg2 + ",_" + etiq + "\n";
        } else if (symbol.equals("!=")) {
            this.body += "bne " + arg1 + "," + arg2 + ",_" + etiq + "\n";
        } else if (symbol.equals(">=")) {
            this.body += "bge " + arg1 + "," + arg2 + ",_" + etiq + "\n";
        } else if (symbol.equals("<=")) {
            this.body += "ble " + arg1 + "," + arg2 + ",_" + etiq + "\n";
        } else if (symbol.equals(">")) {
            this.body += "bgt " + arg1 + "," + arg2 + ",_" + etiq + "\n";
        } else if (symbol.equals("<")) {
            this.body += "blt " + arg1 + "," + arg2 + ",_" + etiq + "\n";
        }
    }

    public void generateAdditionFinalCode(String arg1, String arg2, String temporal, int tableRef, String symbol) {
        int stackPos = 0;
        String word1 = this.getMathValue("$t9", arg1, tableRef);
        String word2 = this.getMathValue("$t8", arg2, tableRef);;
        temporal = "$" + temporal;

        if (symbol.equals("+")) {
            this.body += "add " + temporal + "," + word1 + "," + word2 + "\n";
        } else if (symbol.equals("-")) {
            this.body += "sub " + temporal + "," + word1 + "," + word2 + "\n";
        } else if (symbol.equals("*")) {
            this.body += "mul " + temporal + "," + word1 + "," + word2 + "\n";
        } else if (symbol.equals("/")) {
            this.body += "div " + temporal + "," + word1 + "," + word2 + "\n";
        }
    }

    public int setOffset(int offset, int newOffset) {
        if (newOffset < offset) {
            return newOffset;
        }
        return offset;
    }

    public int setLastOffset(int current, int newOffset) {
        if(newOffset > current){
            return newOffset;
        }
        return current;
    }

    public String getFinalValue(String temp, String word, int tableRef) {
        int pos = this.getPositionInStack(word, tableRef);
        String type = this.temporalRow.type;
        System.out.println("MiType: " + type);
        System.out.println("Word: " + word);
        System.out.println("Table: " + tableRef);
        if (type.equals("int")) {
            return this.getMathValue(temp, word, tableRef);
        } else if (type.equals("char")) {
            return this.getCharValue(temp, word, tableRef);
        } else if (type.equals("boolean")) {
            return this.getCharValue(temp, word, tableRef);
        } else if (type.equals("null")) {
            if (this.isDigit(word)) {
                return word;
            } else if (word.contains("'")) {
                return word;
            } else if (this.isTemporal(word)) {
                return "$" + word;
            } else if (word.equals("true") || word.equals("false")) {
                return this.booleanToByte(word) + "";
            }
        }
        return "null";
    }

    public String getCharValue(String temporal, String value, int tableRef) {
        if (this.isTemporal(value)) {
            this.body += " move " + temporal + ",$" + value + "\n";
            return temporal;
        } else {
            int stackPos = this.getPositionInStack(value, tableRef);
            this.body += "lb " + temporal + "," + stackPos + "($fp)\n";
            return temporal;
        }

    }

    public String getMathValue(String temporal, String value, int tableRef) {
        if (this.isDigit(value)) {
            this.body += "li " + temporal + "," + value + "\n";
            return temporal;
        } else if (this.isTemporal(value)) {
            this.body += " move " + temporal + ",$" + value + "\n";
            return temporal;
        } else {
            int stackPos = this.getPositionInStack(value, tableRef);
            System.out.println(value + " ************* " + stackPos);
            this.body += "lw " + temporal + "," + stackPos + "($fp)\n";
            return temporal;
        }

    }

    public void generateWriteFinalCode(String arg1, String type, int tableId) {
        int stackPos = this.getPositionInStack(arg1, tableId);
        if (type.equals("variable")) {
            type = this.temporalRow.type;
            if (type.equals("int")) {
                this.body += "li $v0,1\n";
                this.body += "lw $a0," + stackPos + "($fp)\n";
                this.body += "syscall\n";
            } else if (type.equals("char")) {
                this.body += "li $v0,11\n";
                this.body += "lb $a0," + stackPos + "($fp)\n";
                this.body += "syscall\n";
            } else if (type.equals("boolean")) {
                this.body += "li $v0,11\n";
                this.body += "lb $a0," + stackPos + "($fp)\n";
                this.body += "syscall\n";
            }
        } else if (type.equals("Number")) {
            this.body += "li $v0,1\n";
            this.body += "li $a0," + arg1 + "\n";
            this.body += "syscall\n";
        } else if (type.equals("char")) {
            this.body += "li $v0,11\n";
            this.body += "li $a0,\'" + arg1 + "\'\n";
            this.body += "syscall\n";
        } else if (type.equals("boolean")) {
            arg1 = this.booleanToByte(arg1) + "";
            this.body += "li $v0,11\n";
            this.body += "li $a0,\'" + arg1 + "\'\n";
            this.body += "syscall\n";
        } else if (type.equals("string")) {
            if (mensajes.isEmpty()) {
                this.data += "_msg" + this.stringCounter + ": .asciiz \"" + arg1 + "\"\n";
                this.body += "li $v0, 4\n";
                this.body += "la $a0," + "_msg" + this.stringCounter + "\n";
                this.body += "syscall\n";
                nombreMensajes.add("_msg" + this.stringCounter);
                mensajes.add(arg1);
                this.stringCounter++;
            }else{
                for (int i = 0; i < mensajes.size(); i++) {
                    if (mensajes.get(i).equalsIgnoreCase(arg1)) {
                        this.body += "li $v0, 4\n";
                        this.body += "la $a0," + nombreMensajes.get(i) + "\n";
                        this.body += "syscall\n";
                    }else{
                        this.data += "_msg" + this.stringCounter + ": .asciiz \"" + arg1 + "\"\n";
                        this.body += "li $v0, 4\n";
                        this.body += "la $a0," + "_msg" + this.stringCounter + "\n";
                        this.body += "syscall\n";
                        nombreMensajes.add("_msg" + this.stringCounter);
                        mensajes.add(arg1);
                        this.stringCounter++;
                    }
                }
            }
            
            
        } else if (type.equals("ArrayElement")) {
            this.body += "li $v0,1\n";
            this.body += "move $a0,$" + arg1 + "\n";
            this.body += "syscall\n";
        }

        this.generateNextLine();
    }

    public boolean isTemporal(String word) {
        String compare = "$t1$t2$t3$t4$t5$t6$t7$t8$t9";

        if (compare.contains(word)) {
            return true;
        }
        return false;
    }

    public void generateNextLine() {
        this.body += "li $v0,4\n";
        this.body += "la $a0,_nextLine\n";
        this.body += "syscall\n";
    }

    public void generateF_ETIQ2FinalCode(String arg1) {
        if (arg1.equals("main")) {
            this.body += "_" + arg1+"Salida" + ":\n";
            this.body += "move $sp,$fp\n";
            this.body += "lw $ra, -8($sp)\n";
            this.body += "lw $fp, -4($sp)\n";
            this.body += "jr $ra\n";
        } else {
            int pos = this.getPositionInStack(arg1, 0);
            String type = this.temporalRow.type;
            this.body += "_" + arg1+"Salida" + ":\n";
            this.body += "move $sp,$fp\n";
            this.body += "lw $fp, -4($sp)\n";
            this.body += "lw $ra, -8($sp)\n";
            this.loadParameters(amount, type, false);
            this.body += "jr $ra\n";
        }
    }

    public void generateF_ETIQFinalCode(String arg1, String arg2) {
        amount = Integer.parseInt(arg2);
        this.currentBegin = 0;
        this.currentFunction = arg1;
        if (arg1.equals("main")) {
            this.body += "li $v0,10\n";
            this.body += "syscall\n";
            this.body += "_" + arg1 + ":\n";
            this.body += "sw $fp, -4($sp)\n";
            this.body += "sw $ra, -8($sp)\n";
            this.body += "move $fp,$sp\n";
        } else {
            int pos = this.getPositionInStack(arg1, 0);
            String type = this.temporalRow.type;
            this.body += "_" + arg1 + ":\n";
            this.body += "sw $fp, -4($sp)\n";
            this.body += "sw $ra, -8($sp)\n";
            this.loadParameters(amount, type, true);
            this.body += "move $fp,$sp\n";
        }
    }

    public void loadParameters(int amount, String type, boolean begin) {
        String[] arr = type.split("->");
        String[] params = arr[0].split("x");
        int offset = 0;
        int size = 0;

        for (int i = 0; i < amount; i++) {
            params[i] = params[i].replaceAll(" ", "");
            size = this.getTypeSize(params[i]);
            if (params[i].equals("int")) {
                if (begin) {
                    this.body += "move $s" + i + ",$a" + i + "\n";
                    this.body += "sw $s" + i + ",-" + (12 + offset) + "($sp)\n";
                    this.lastOffset = (12 + offset) * -1;
                    this.currentBegin += size;
                } else {
                    this.body += "lw $s" + i + ",-" + (12 + offset) + "($sp)\n";
                }
            } else if (params[i].equals("boolean")) {
                if (begin) {
                    this.body += "move $s" + i + ",$a" + i + "\n";
                    this.body += "sb $s" + i + ",-" + (12 + offset) + "($sp)\n";
                    this.lastOffset = (12 + offset) * -1;
                    this.currentBegin += size;
                } else {
                    this.body += "lb $s" + i + ",-" + (12 + offset) + "($sp)\n";
                }
            } else if (params[i].equals("char")) {
                if (begin) {
                    this.body += "move $s" + i + ",$a" + i + "\n";
                    this.body += "sb $s" + i + ",-" + (12 + offset) + "($sp)\n";
                    this.lastOffset = (12 + offset) * -1;
                    this.currentBegin += size;
                } else {
                    this.body += "lb $s" + i + ",-" + (12 + offset) + "($sp)\n";
                }
            }
            offset += size;
        }
    }

    public void generateAssignmentFinalCode(String arg1, String arg2, String temporal, int tableRef) {
        int stackPos1 = this.getPositionInStack(temporal, tableRef);
        String type = this.temporalRow.type;

        if (type.contains("->")) {
            type = this.getFunctionReturnType(type);
        }

        if (type.equals("int")) {
            if (this.isDigit(arg1)) {
                this.body += "li $t9," + arg1 + "\n";
                this.body += "sw $t9," + stackPos1 + "($fp)\n";
                this.lastVariableSize = 4;
                this.lastOffset = stackPos1;
            } else if (this.isTemporal(arg1)) {
                this.body += "sw $" + arg1 + ", " + stackPos1 + "($fp)" + "\n";
                this.lastVariableSize = 4;
                this.lastOffset = stackPos1;
            } else {
                int stackPos2 = this.getPositionInStack(arg1, tableRef);
                this.body += "lw $t9," + stackPos2 + "($fp)" + "\n";
                this.body += "sw " + "$t9," + stackPos1 + "($fp)" + "\n";
                this.lastVariableSize = 4;
                this.lastOffset = stackPos1;
            }
        } else if (type.equals("char")) {
            if (arg2.equals("string")) {
                this.body += "li $t9," + "\'" + arg1 + "\'" + "\n";
                this.body += "sb $t9," + stackPos1 + "($fp)\n";
                this.lastVariableSize = 1;
                this.lastOffset = stackPos1;
            } else if (arg2.equals("variable")) {
                int stackPos2 = this.getPositionInStack(arg1, tableRef);
                this.body += "lb $t9," + stackPos2 + "($fp)\n";
                this.body += "sb $t9," + stackPos1 + "($fp)\n";
                this.lastVariableSize = 1;
                this.lastOffset = stackPos1;
            } else if (arg2.equals("Call")) {
                this.body += "sb $" + arg1 + ", " + stackPos1 + "($fp)" + "\n";
                this.lastVariableSize = 1;
                this.lastOffset = stackPos1;
            }
        } else if (type.equals("boolean")) {
            if (arg2.equals("boolean")) {
                arg1 = this.booleanToByte(arg1) + "";
                this.body += "li $t9," + "\'" + arg1 + "\'" + "\n";
                this.body += "sb $t9," + stackPos1 + "($fp)\n";
                this.lastVariableSize = 1;
                this.lastOffset = stackPos1;
            } else if (arg2.equals("variable")) {
                int stackPos2 = this.getPositionInStack(arg1, tableRef);
                this.body += "lb $t9," + stackPos2 + "($fp)\n";
                this.body += "sb $t9," + stackPos1 + "($fp)\n";
                this.lastVariableSize = 1;
                this.lastOffset = stackPos1;
            } else if (arg2.equals("Call")) {
                this.body += "sb $" + arg1 + ", " + stackPos1 + "($fp)" + "\n";
                this.lastVariableSize = 1;
                this.lastOffset = stackPos1;
            }
        }
    }

    public int booleanToByte(String value) {
        if (value.equals("true")) {
            return 1;
        } else {
            return 0;
        }
    }

    public String byteToBoolean(String number) {
        if (number.equals("1")) {
            return "true";
        } else {
            return "false";
        }
    }

    public int getPositionInStack(String id, int tableRef) {
        int stackPos = getStackBeginning(tableRef);
        int offset = this.getOffset(id, tableRef);
        if (this.temporalRow.isParameter) {
            stackPos = 8;
        }
        stackPos += offset;
        stackPos *= -1;
        return stackPos;
    }

    public int getOffset(String id, int tableRef) {
        int offset = -1;
        this.getTableByID(this.symbolTables.root, this.symbolTables.root.getLefterSon(), tableRef);
        Row row = this.getRowById(this.node, id);
        this.temporalRow = row;
        offset = row.offset;
        return offset;
    }

    public int getStackBeginning(int tableRef) {
        return this.begin + this.currentBegin;
    }

    public int getParametersSize() {
        int size = 0;
        SymbolTable table = this.getTableFromNode(this.node);

        for (int i = 0; i < table.list.size(); i++) {
            if (table.list.get(i).isParameter) {
                size += this.getTypeSize(table.list.get(i).type);
            }
        }
        return size;
    }

    public void generateASM(String name) {
        this.createTemps();
        this.generateFinalCode();
        this.code = this.body + this.data;
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("./" + name + ".asm");
            pw = new PrintWriter(fichero);
            pw.println(this.code);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
    }

    public void createTemps() {
        for (int i = 7; i >= 0; i--) {
            this.tempStack.push("$t" + i);
        }
    }
    
    public ArrayList optimizer(ArrayList<RowIntermediate> cuad){
        ArrayList<String> nombres = new ArrayList();
        ArrayList<String> tempCambiado = new ArrayList();
        for (int i = 0; i < cuad.size(); i++) {
            String tempOp = cuad.get(i).getOperator();
            String tempArg1 = cuad.get(i).getArg1();
            String tempArg2 = cuad.get(i).getArg2();
            String tempRes = cuad.get(i).getResult();
            if ((tempRes.startsWith("t")&&((tempRes.endsWith("8"))||
                    (tempRes.endsWith("9"))||tempRes.length()>2))) {
                nombres.add(tempRes);
            }
            if (tempOp.equals("+")||tempOp.equals("-")||tempOp.equals("*")||
                    tempOp.equals("/")||tempOp.equals(":=")||
                    tempOp.equals("=[]")||tempOp.equals("[]=")) {
                if (tempArg1.startsWith("t")&&
                    ((tempArg1.endsWith("0"))||(tempArg1.endsWith("1"))||
                    (tempArg1.endsWith("2"))||(tempArg1.endsWith("3"))||
                    (tempArg1.endsWith("4"))||(tempArg1.endsWith("5")||
                    (tempArg1.endsWith("6")))||(tempArg1.endsWith("7"))||
                    (tempArg1.endsWith("8"))||(tempArg1.endsWith("9")))) {
                    tempCambiado.add(tempArg1);
                }
                if (tempArg2.startsWith("t")&&
                    ((tempArg2.endsWith("0"))||(tempArg2.endsWith("1"))||
                    (tempArg2.endsWith("2"))||(tempArg2.endsWith("3"))||
                    (tempArg2.endsWith("4"))||(tempArg2.endsWith("5")||
                    (tempArg2.endsWith("6")))||(tempArg2.endsWith("7"))||
                    (tempArg2.endsWith("8"))||(tempArg2.endsWith("9")))) {
                    tempCambiado.add(tempArg2);
                }
                
            }
        }
        for (int i = 0; i < nombres.size(); i++) {
            for (int j = 0; j < tempCambiado.size(); j++) {
                if (nombres.get(i).equals(tempCambiado.get(j))) {
                    tempCambiado.set(j, tempCambiado.get(i));
                }
            }
        }
        for (int i = 0; i < nombres.size(); i++) {
            for (int j = 0; j < cuad.size(); j++) {
                String tempArg1 = cuad.get(j).getArg1();
                String tempArg2 = cuad.get(j).getArg2();
                String tempRes = cuad.get(j).getResult();
                String viejoTemp = nombres.get(i);
                String nuevoTemp = tempCambiado.get(i);
                if (tempRes.equals(viejoTemp)) {
                    cuad.get(j).setResult(nuevoTemp);
                }else if (tempArg1.equals(viejoTemp)) {
                    cuad.get(j).setArg1(nuevoTemp);
                }else if (tempArg2.equals(viejoTemp)) {
                    cuad.get(j).setArg2(nuevoTemp);
                }
            }  
        }
        return cuad;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the imbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Tree.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Tree.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Tree.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Tree.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Tree().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ShowTables;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JDialog jDialog1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea jTextArea1;
    public javax.swing.JTree jTree1;
    private javax.swing.JTable tablaCuadruplos;
    // End of variables declaration//GEN-END:variables
    MyTree result = new MyTree();
    MyTree symbolTables = new MyTree(new TreeNode("Symbol Tables", null));
    String type = "", tag = "";
    SymbolTable table = new SymbolTable("");
    TreeNode node = new TreeNode(table, null);
    boolean isInteger = true, hasSymbol = false, hasReturn = false, finishedInspection = false;
    String actualType = "";
    String parentType = "", parent = "";
    int returnCounter = 0;
    int line = 0, column = 0;
    IntermediateTable cuadruplos = new IntermediateTable();
    String globalTag = "main";
    boolean hasSemanticErrors = false;
    int blockID = 0;
    int currentID = 0;
    String code = "";
    String data = ".data\n";
    String body = ".text\n" + ".globl main\n" + "main:\n";
    int offset = 0, paramsOffset = 0;
    Stack<Integer> offsetStack = new Stack<Integer>();
    Stack<String> tempStack = new Stack<String>();
    Stack<String> busyTempStack = new Stack<String>();
    Row temporalRow = new Row();
    int stringCounter = 0;
    int paramCounter = 0;
    String currentF_ETIQ = "";
    int lastOffset = 0, lastVariableSize = 0, amount = 0;
    int currentBegin = 0, begin = 8;
    boolean isFirst = true, isFirstParam = true;
    String currentFunction = "main";
    ArrayList<String> nombreMensajes = new ArrayList();
    ArrayList<String> mensajes = new ArrayList();
}
