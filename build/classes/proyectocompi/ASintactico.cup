package proyectocompi;	
import java.util.ArrayList;
import java_cup.runtime.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;

parser code{:
	MyTree tree = new MyTree();
	Symbol next;
	TreeNode node = new TreeNode();
	int level = 0;
	ArrayList<TreeNode> functions = new ArrayList();
	ArrayList<TreeNode> operations = new ArrayList();
	ArrayList<TreeNode> body = new ArrayList();
	ArrayList<TreeNode> arrayElements = new ArrayList();
	ArrayList<TreeNode> params = new ArrayList();
	ArrayList<TreeNode> params2 = new ArrayList();
	ArrayList<TreeNode> cases = new ArrayList();
	ArrayList<TreeNode> comparisons = new ArrayList();
	ArrayList<TreeNode> ifs = new ArrayList();
	ArrayList<TreeNode> assignments = new ArrayList();

	public void report_error(String errorBody, Object info) {
		next = (Symbol)info;
		System.out.println("Next: " + next.value);
	}

	public void report_fatal_error(String errorBody, Object info) {
		next = (Symbol)info;
		System.out.println("Next: " + next.value);
		System.out.println("Unexpected Token");
	}

	public int error_sync_size(){
		return 1;
	}

	public void unrecovered_syntax_error(Symbol s){
		System.out.println("Unexpected token: " + next.value + " in line: " + next.left + "; column: " + next.right);
	}

	public void callError(int line, int column){
		if(next.sym == sym.leftParenthesis){
			printError(line,next.right - 1,"Missing function name");
		}else if(next.sym == sym.VariableName || next.sym == sym.Number || 
			next.sym == sym.STRING || next.sym == sym.BooleanValue){
			printError(line,next.right-1,"Missing '(' or ','");
		}else if(next.sym == sym.Delimeter || next.sym == sym.rightParenthesis){
			printError(line,column,"Syntax error in function parameter");
		}else if(next.sym == sym.EOL){
			printError(line,column,"Missing ')'");
		}
	}

	public void assignmentError(int line, int column){
		printError(line,column,"Syntax error un assigment");
	}

	public void missingCallOrTypeError(int line, int column){
		if(next.sym == sym.VariableName){
			printError(line,next.right - 1,"Syntax error in call or in variable type");		
		}else if(next.sym == sym.Assign ||next.sym == sym.MinusEqual ||next.sym == sym.PlusEqual ||
				next.sym == sym.DivEqual ||next.sym == sym.MultEqual){
			printError(line,next.right-1,"Syntax error in variable name");
		}else if(next.sym == sym.leftParenthesis){
			printError(line,column,"Missing for");
		}else if(next.sym == sym.Call || next.sym == sym.Type || next.sym == sym.ArrayType || 
				next.sym == sym.If ||next.sym == sym.For || next.sym == sym.While || next.sym == sym.Switch ||
				next.sym == sym.RightKey){
			printError(line,column,"Missing  '(' or '{'");
		}
	}

	public void structureError(int line, int column){
		if(next.sym == sym.leftParenthesis){
			printError(line,column,"Missing if/elseif or while or switch");	
		}else if(next.sym == sym.VariableName || next.sym == sym.Number || next.sym == sym.BooleanValue||
			next.sym == sym.STRING){
			printError(line,next.right-1,"Syntax error in comparison for structure or in function name");
		}else if(next.sym == sym.Equal || next.sym == sym.GreaterThan|| next.sym == sym.GreaterEqual||
			     next.sym == sym.LessThan || next.sym == sym.LessEqual ||next.sym == sym.NotEqual){
			printError(line,next.right-1,"Missing left value in comparison");
		}else if(next.sym == sym.And || next.sym == sym.Or || next.sym == sym.rightParenthesis){
			printError(line,next.right-1,"Missing right value in comparison");
		}else if(next.sym == sym.LeftKey){
			printError(line,column,"Missing ')' or else");
		}else if(next.sym == sym.Elseif || next.sym == sym.Else){
			printError(next.left+1,next.right,"Missing '}'");
		}
	}

	public void returnError(int line, int column){
		 if(sym.RightKey == next.sym){
			printError(next.left,column,"Syntax error in return");
		}else{
			printError(next.left-1,next.right,"Missing '}'");
		}
	}

	public void switchError(int line, int column){
		if(next.sym == sym.VariableName){
			printError(line,column,"Missing '('");
		}else if(next.sym == sym.rightParenthesis){
			printError(line,column,"Missing variable for switch");
		}else if(next.sym == sym.LeftKey){
			printError(line,column,"Missing ')'");
		}else if(next.sym == sym.Case){
			printError(line,column,"Missing '{'");
		}
	}

	public void caseHeaderError(int line, int column){
		if(next.sym == sym.Number || next.sym == sym.STRING || next.sym == sym.Default){
			printError(next.left+1,next.right-1,"Syntax error in case");
		}else if(next.sym == sym.TwoPoints){
			printError(next.left+1,next.right-1,"Missing case value");
		}else{
			printError(next.left+1,next.right-1,"Syntax error in case");
		}
	}

	public void caseEndingError(int line, int column){
		if(next.sym == sym.EOL){
			printError(line,next.right,"Syntax error in endcase");
		}else if(next.sym == sym.Case || next.sym == sym.RightKey){
			printError(line,next.right,"Syntax error in endcase");
		}
	}

	public void functionError(int line, int column, String word){
		if(word.equals("Function")){
			printError(line,next.right,"Syntax error in function name");	
		}else if(word.equals("BeforeType")){
			if(next.sym == sym.Type){
				printError(line,column,"Missing '(' or ',' or ':'");
			}else if(next.sym == sym.VariableName){
				printError(line,column,"Syntax error parameter types");
			}else if(next.sym == sym.Delimeter || next.sym == sym.rightParenthesis){
				printError(line,column,"Syntax error in parameters");
			}else if (next.sym == sym.TwoPoints) {
				printError(line,column,"Missing ')'");
			}		
		}else if(word.equals("Type")){
			printError(line,column,"Syntax error in return type");
		}
	}

	public void addMultipleNodes(TreeNode node, ArrayList<TreeNode> list,boolean reverse){
		if(reverse){
			for(int i = list.size()-1; i >=0; i--){
				addNodeToTree(node,list.get(i));
			}
		}else{
			for(int i = 0; i < list.size(); i++){
				addNodeToTree(node,list.get(i));
			}
		}
	}

	public boolean verifyBody(int size){
		if(size>body.size()){
			return false;
		}
		return true;
	}

	public void addNodeToTree(TreeNode parent, TreeNode node){
		node.setParent(parent);
		parent.addSon(node);
	}

	public void printError(int line, int column, String message){
		System.out.println("Syntax error in line: " + line + " Column: " + column + 
					"; "  + message);
	}
:};

terminal Number;
terminal VariableName; 
terminal BooleanValue; 
terminal Type; 
terminal STRING;  
terminal MultOP; 
terminal DivOP; 
terminal AddOP; 
terminal SubOP; 
terminal Assign; 
terminal PlusEqual;
terminal MinusEqual;
terminal MultEqual;
terminal DivEqual; 
terminal And; 
terminal Or; 
terminal Equal; 
terminal NotEqual; 
terminal GreaterThan; 
terminal LessThan;
terminal GreaterEqual; 
terminal LessEqual; 
terminal If; 
terminal Elseif; 
terminal Else; 
terminal Case; 
terminal Endcase;
terminal Default; 
terminal Switch;
terminal Function; 
terminal Call;
terminal Return; 
terminal EOL;
terminal Delimeter; 
terminal leftParenthesis; 
terminal rightParenthesis; 
terminal ThreePoints; 
terminal LeftKey; 
terminal RightKey; 
terminal TwoPoints;
terminal Main;
terminal For;
terminal While;
terminal LeftBracket; 
terminal RightBracket;
terminal ArrayType;

non terminal leftValue; 
non terminal Assignment; 
non terminal SingleAssignment; 
non terminal Declaration; 
non terminal AssignmentOperator;   
non terminal AddSub; 
non terminal MultDiv; 
non terminal MultipleAddSub; 
non terminal MultipleMultDiv; 
non terminal ArithmeticOperation; 
non terminal Comparison; 
non terminal AndOr; 
non terminal RelationalOperator;
non terminal ComparisonInParenthesis;
non terminal MultipleComparison;
non terminal IF;
non terminal ELSEIF;
non terminal SWITCH;
non terminal CASE;
non terminal CaseHeader;
non terminal CaseEnding; 
non terminal CaseValues;
non terminal ComparisonSwitch;
non terminal FUNCTION;
non terminal Params;
non terminal ParamsOrEmpty; 
non terminal RETURN;
non terminal FunctionHeader;
non terminal FunctionBody;  
non terminal CALL;
non terminal CallParams; 
non terminal CallParamsOrEmpty;
non terminal CallHeader; 
non terminal BODY; 
non terminal MAIN; 
non terminal PROGRAM;
non terminal FOR;
non terminal WHILE;
non terminal WhileForBody; 
non terminal ERROR;
non terminal ArrayAssignment;
non terminal Element;
non terminal VariableType; 
non terminal paramsFor; 
non terminal declarationFor;
non terminal rangeFor; 


/*Gramatica del programa*/
PROGRAM ::= MAIN:m FUNCTION{:
					DefaultTreeModel model = new DefaultTreeModel(new DefaultMutableTreeNode());
					parser.tree = new MyTree(new TreeNode("Program", null));
					parser.addNodeToTree(parser.tree.root, (TreeNode)m);
					TreeNode node = new TreeNode("Functions", null);
					parser.addMultipleNodes(node,parser.functions,false);
					parser.addNodeToTree(parser.tree.root,node);

					parser.tree.showTree(null,parser.tree.root,model,(DefaultMutableTreeNode)model.getRoot());
					parser.tree.tree.setVisible(true);
			:};

/*Gramatica para main*/
MAIN ::= Main leftParenthesis rightParenthesis FunctionBody:body{:
				TreeNode node = new TreeNode("Main",null);
				parser.addNodeToTree(node,(TreeNode)body);
				RESULT = node;
		 :}|
		 error:e{:
		 		System.out.println("Missing main");
		 :} FunctionBody;

/*Gramatica para el body del programa*/
BODY ::=  BODY ERROR|
		  BODY:B Declaration:D {:
		  		ArrayList<TreeNode> nodes = new ArrayList();
		  		if(B == null){
		  			nodes = new ArrayList();
		  		}else{
		  			nodes = ((ArrayList<TreeNode>)B);
		  		}
		  		nodes.add((TreeNode)D);
		  		RESULT = nodes;
		  :}| 
		  BODY:B CALL:C{:
		  		ArrayList<TreeNode> nodes = new ArrayList();
		  		if(B == null){
		  			nodes = new ArrayList();
		  		}else{
		  			nodes = ((ArrayList<TreeNode>)B);
		  		}
		  		nodes.add((TreeNode)C);
		  		RESULT = nodes;
		  :}|  
		  BODY:B IF:I {:
		  		ArrayList<TreeNode> nodes = new ArrayList();
		  		if(B == null){
		  			nodes = new ArrayList();
		  		}else{
		  			nodes = ((ArrayList<TreeNode>)B);
		  		}
		  		nodes.add((TreeNode)I);
		  		RESULT = nodes;
		  :}  | 
		  BODY:B SWITCH:S {:
		  		ArrayList<TreeNode> nodes = new ArrayList();
		  		if(B == null){
		  			nodes = new ArrayList();
		  		}else{
		  			nodes = ((ArrayList<TreeNode>)B);
		  		}
		  		nodes.add((TreeNode)S);
		  		RESULT = nodes;
		  :} | 
		  BODY:B SingleAssignment:SA {:
		  		ArrayList<TreeNode> nodes = new ArrayList();
		  		if(B == null){
		  			nodes = new ArrayList();
		  		}else{
		  			nodes = ((ArrayList<TreeNode>)B);
		  		}
		  		nodes.add((TreeNode)SA);
		  		RESULT = nodes;
		  :}|
		  BODY:B FOR:F {:
		  		ArrayList<TreeNode> nodes = new ArrayList();
		  		if(B == null){
		  			nodes = new ArrayList();
		  		}else{
		  			nodes = ((ArrayList<TreeNode>)B);
		  		}
		  		nodes.add((TreeNode)F);
		  		RESULT = nodes;
		  :}|
		  BODY:B WHILE:W{:
		  		ArrayList<TreeNode> nodes = new ArrayList();
		  		if(B == null){
		  			nodes = new ArrayList();
		  		}else{
		  			nodes = ((ArrayList<TreeNode>)B);
		  		}
		  		nodes.add((TreeNode)W);
		  		RESULT = nodes;
		  :}|;

ERROR ::= Call error:e{:
				System.out.println("Call error EOL");
				parser.callError(eleft + 1, eright + 1);
		  :} EOL| 
		  VariableType error:e{:
		  		System.out.println("Type error EOL");
		  		parser.assignmentError(eleft + 1, eright + 1);
		  :} EOL|error:e{:
		  		System.out.println("Missing Call or type");
		  		parser.missingCallOrTypeError(eleft + 1, eright +1);
		  :} EOL|
		  error:e{:
		  		System.out.println("While or For or if");
		  		parser.structureError(eleft+1, eright+1);
		  :} WhileForBody;

/*Gramatica para llamados a funciones*/
CALL ::= Call VariableName:name CallHeader EOL {:
		 		TreeNode node = new TreeNode("Call",null);
		 		TreeNode node2 = new TreeNode("FunctionName",null);
		 		TreeNode node3 = new TreeNode("FunctionParams",null);
		 		TreeNode nameNode = new TreeNode(name.toString(),null);
		 		parser.addNodeToTree(node,node2);
		 		parser.addNodeToTree(node2,nameNode);

		 		if(parser.params.size() > 0){
		 			parser.addNodeToTree(node,node3);
		 			parser.addMultipleNodes(node3,parser.params,false);
		 		}
		 		RESULT = node;
		 		parser.params = new ArrayList();
		 :};
CallHeader ::= leftParenthesis CallParamsOrEmpty rightParenthesis;
CallParams ::= leftValue:LV {:parser.params.add((TreeNode)LV);:} | 
			   CallParams Delimeter leftValue:LV {:parser.params.add((TreeNode)LV);:};
CallParamsOrEmpty ::= CallParams|;

/*Gramatica para funciones*/
FUNCTION ::= Function VariableName:functionName FunctionHeader:FH  FunctionBody:body FUNCTION{:
					TreeNode node = new TreeNode("function", null);
					TreeNode name = new TreeNode("name", null);
					TreeNode params2 = new TreeNode("Parameters", null);
					TreeNode type = new TreeNode("ReturnType", null);
					TreeNode nameNode = new TreeNode(functionName.toString(), null);
					parser.addNodeToTree(node,name);
					parser.addNodeToTree(node,type);
					parser.addNodeToTree(node,params2);
					parser.addNodeToTree(node,(TreeNode)body);
					parser.addNodeToTree(name,nameNode);
					System.out.println("Params: " + parser.params2);
					parser.addMultipleNodes(params2,parser.params2,false);
					parser.addNodeToTree(type,(TreeNode)FH);
					parser.functions.add(node);
					parser.params2 = new ArrayList();
			 :}|
			 error:e{:
			 	System.out.println("Function");
			 	parser.functionError(eleft+1,eright+1,"Function");
			 :} FunctionBody FUNCTION|;
FunctionHeader ::= leftParenthesis ParamsOrEmpty rightParenthesis TwoPoints VariableType:type{:
						RESULT = type;
				   :}|
				   error:e{:
				   		System.out.println("BeforeType");
			 			parser.functionError(eleft+1,eright+1,"BeforeType");
				   	:} VariableType|
				   	leftParenthesis ParamsOrEmpty rightParenthesis error:e{:
				   		System.out.println("Type");
			 			parser.functionError(eleft+1,eright+1,"Type");
				   	:};
FunctionBody ::= LeftKey BODY:body RETURN RightKey{:
						TreeNode bodyNode = new TreeNode("Body",null);
						parser.body = (ArrayList<TreeNode>)body;
						parser.addMultipleNodes(bodyNode,parser.body,false);
						RESULT = bodyNode;						
				:}|
				 LeftKey BODY error:e{:
				 		System.out.println("return");
				 		parser.returnError(eleft+1,eright+1);
				 :}|
				 error:e{:
				 	System.out.println("Fixing");
				 :} BODY RETURN RightKey;
Params ::= VariableType:type VariableName:name {:
				TreeNode node = new TreeNode("Parameter", null);
				TreeNode typeNode = new TreeNode("Type", null);
				TreeNode nameNode = new TreeNode("id", null);
				TreeNode node1 = new TreeNode(type.toString(), null);
				TreeNode node2 = new TreeNode(name.toString(), null);
				parser.addNodeToTree(node,typeNode);
				parser.addNodeToTree(node,nameNode);
				parser.addNodeToTree(typeNode,node1);
				parser.addNodeToTree(nameNode,node2);
				parser.params2.add(node);
	       :}| 
		   Params Delimeter VariableType:type VariableName:name{:
		   		TreeNode node = new TreeNode("Parameter", null);
				TreeNode typeNode = new TreeNode("Type", null);
				TreeNode nameNode = new TreeNode("id", null);
				TreeNode node1 = new TreeNode(type.toString(), null);
				TreeNode node2 = new TreeNode(name.toString(), null);
				parser.addNodeToTree(node,typeNode);
				parser.addNodeToTree(node,nameNode);
				parser.addNodeToTree(typeNode,node1);
				parser.addNodeToTree(nameNode,node2);
				parser.params2.add(node);
		   :};
ParamsOrEmpty ::= Params|;
RETURN ::= Return leftValue EOL;

/*Gramatica para declaraciones y asignaciones*/
Declaration ::= VariableType:VType Assignment EOL {:
					TreeNode declaration = new TreeNode("Declaration",null);
					TreeNode type = new TreeNode("Type",null);
					TreeNode typeNode = new TreeNode(VType.toString(),null);
					parser.addNodeToTree(declaration,type);
					parser.addMultipleNodes(declaration,parser.assignments,false);
					parser.addNodeToTree(type,typeNode);
					parser.assignments = new ArrayList();
					RESULT = declaration;
				:};
Assignment ::= VariableName:name AssignmentOperator:operator leftValue:leftVal {:
					TreeNode assignment = new TreeNode("Assignment",null);
					TreeNode VName = new TreeNode("id",null);
					TreeNode value = new TreeNode("value",null);
					TreeNode nameNode = new TreeNode(name.toString(),null);
					parser.addNodeToTree(assignment,VName);
					parser.addNodeToTree(assignment,(TreeNode)operator);
					parser.addNodeToTree(assignment,value);
					parser.addNodeToTree(VName,nameNode);
					parser.addNodeToTree(value,(TreeNode)leftVal);
					parser.assignments.add(assignment);
			   :}| 
               Assignment Delimeter VariableName:name AssignmentOperator:operator leftValue:leftVal {:
					TreeNode assignment = new TreeNode("Assignment",null);
					TreeNode VName = new TreeNode("id",null);
					TreeNode value = new TreeNode("value",null);
					TreeNode nameNode = new TreeNode(name.toString(),null);
					parser.addNodeToTree(assignment,VName);
					parser.addNodeToTree(assignment,(TreeNode)operator);
					parser.addNodeToTree(assignment,value);
					parser.addNodeToTree(VName,nameNode);
					parser.addNodeToTree(value,(TreeNode)leftVal);
					parser.assignments.add(assignment);
			   :}|
			   VariableName:name{:
			   		TreeNode node = new TreeNode("VariableName", null);
			   		TreeNode nameNode = new TreeNode(name.toString(), null);
			   		parser.addNodeToTree(node,nameNode);
			   		parser.assignments.add(node);
			   	:}| 
			   Assignment Delimeter VariableName:name{:
			   		TreeNode node = new TreeNode("VariableName", null);
			   		TreeNode nameNode = new TreeNode(name.toString(), null);
			   		parser.addNodeToTree(node,nameNode);
			   		parser.assignments.add(node);
			   	:}; 
leftValue ::= AddSub:AS{:
					RESULT = AS;
			  :}|
              BooleanValue:Boolean{:
              		TreeNode Bvalue = new TreeNode("Bolean",null);
              		TreeNode value = new TreeNode(Boolean.toString(),null); 
              		parser.addNodeToTree(Bvalue,value);
              		RESULT = Bvalue;
              :}|
              STRING:word{:
              		TreeNode Svalue = new TreeNode("String",null);
              		TreeNode value = new TreeNode(word.toString(),null); 
              		parser.addNodeToTree(Svalue,value);
              		RESULT = Svalue;
              :}|
              CALL:C{:RESULT = C;:}|
              ArrayAssignment:AA {:RESULT = AA;:};
AssignmentOperator ::= Assign {:RESULT = new TreeNode(":=",null);:} | 
                       PlusEqual {:RESULT = new TreeNode("+=",null);:}| 
                       MinusEqual {:RESULT = new TreeNode("-=",null);:}| 
                       MultEqual {:RESULT = new TreeNode("*=",null);:}| 
                       DivEqual{:RESULT = new TreeNode("/=",null);:};
VariableType ::= Type:t {:RESULT = new TreeNode(t.toString(),null);:} | 
                 ArrayType:t {:RESULT = new TreeNode(t.toString(),null);:}; 
ArrayAssignment ::= Type:type LeftBracket AddSub:size RightBracket{:
						TreeNode node = new TreeNode("ArrayAssignment",null);
						TreeNode typeNode = new TreeNode("ArrayType",null);
						TreeNode sizeNode = new TreeNode("ArraySize",null);
						TreeNode node1 = new TreeNode(type.toString(),null);
						TreeNode node2 = (TreeNode)size;
						parser.addNodeToTree(node,typeNode);
						parser.addNodeToTree(node,sizeNode);
						parser.addNodeToTree(typeNode,node1);
						parser.addNodeToTree(sizeNode,node2);
						RESULT = node;
					:} | 
                    LeftBracket Element RightBracket{:
                    	TreeNode node = new TreeNode("ArrayAssignment",null);
                    	TreeNode node2 = new TreeNode("Elements",null);
                    	parser.addNodeToTree(node,node2);
                    	parser.addMultipleNodes(node2,parser.arrayElements,false);
                    	RESULT = node;
                    	parser.arrayElements = new ArrayList();
                    :};
Element ::= leftValue:LV {:
				parser.arrayElements.add((TreeNode)LV);
			:} | 
            Element Delimeter leftValue:LV {:
            	parser.arrayElements.add((TreeNode)LV);
            :};
SingleAssignment ::= VariableName:name AssignmentOperator:operator leftValue:LV EOL {:
					 		TreeNode node = new TreeNode("Assignment",null);
					 		TreeNode id = new TreeNode("id", null);
					 		TreeNode value = new TreeNode("value", null);
					 		TreeNode nameNode = new TreeNode(name.toString(), null);
					 		TreeNode operatorNode = new TreeNode(operator.toString(), null);
					 		parser.addNodeToTree(node,id);
					 		parser.addNodeToTree(node,operatorNode);
					 		parser.addNodeToTree(node,value);
					 		parser.addNodeToTree(id,nameNode);
					 		parser.addNodeToTree(value,(TreeNode)LV);
					 		RESULT = node;
					 :};

/*Gramatica para switch*/
SWITCH ::= Switch  ComparisonSwitch:variable LeftKey  CASE RightKey{:
				TreeNode node = new TreeNode("Switch",null);
				parser.addNodeToTree(node, (TreeNode)variable);
				parser.addMultipleNodes(node,parser.cases,false);
				RESULT = node;
				parser.cases = new ArrayList();
				System.out.println("Switch");
			:}|
			Switch error:e{:
				System.out.println("Switch");
				parser.switchError(eleft + 1, eright + 1);
			:} CASE RightKey;
ComparisonSwitch ::= leftParenthesis VariableName:name rightParenthesis {:
							TreeNode node = new TreeNode("switchVariable",null);
							TreeNode nameNode = new TreeNode(name.toString(),null);
							parser.addNodeToTree(node,nameNode);
							RESULT = node;
					 :};
CaseHeader ::=	Case CaseValues:value TwoPoints{:
					TreeNode node = new TreeNode("Value", null);
					parser.addNodeToTree(node,(TreeNode)value);
					RESULT = node;
					System.out.println("CaseHeader");
				:};
CaseEnding ::= BODY Endcase EOL{:
					TreeNode body = new TreeNode("Body", null);
					parser.addMultipleNodes(body,parser.body,false);
					RESULT = body;
					parser.body = new ArrayList();
					System.out.println("CaseEnding");
				:}|
				BODY error:e{:
					System.out.println("Case ending");
					parser.caseEndingError(eleft+1, eright+1);
				:}; 
CASE ::= CASE  CaseHeader:header CaseEnding:ending{:
				TreeNode node = new TreeNode("Case",null);
				parser.addNodeToTree(node,(TreeNode)header);
				parser.addNodeToTree(node,(TreeNode)ending);
				parser.cases.add(node);
				System.out.println("Case");
		 :}|
				error:e{:
					System.out.println("CaseHeader");
					parser.caseHeaderError(eleft+1, eright+1);
				:} CaseEnding|;
CaseValues ::= Number:number {:RESULT = new TreeNode(number.toString(), null);:}|
               STRING:string{:RESULT = new TreeNode(string.toString(), null);:}|
               Default:def{:RESULT = new TreeNode(def.toString(), null);:};

/*Gramatica para if*/
IF ::= If ComparisonInParenthesis:CP WhileForBody:body ELSEIF{:
			TreeNode ifNode = new TreeNode("If", null);
			parser.addNodeToTree(ifNode,(TreeNode)CP);
			parser.addNodeToTree(ifNode,(TreeNode)body);
			parser.addMultipleNodes(ifNode,parser.ifs,true);
			parser.ifs = new ArrayList();
			RESULT =ifNode;
			System.out.println("If");
	   :};
ELSEIF ::= Elseif ComparisonInParenthesis:CP WhileForBody:body ELSEIF{:
				TreeNode elseif = new TreeNode("ElseIf", null);
				parser.addNodeToTree(elseif,(TreeNode)CP);
				parser.addNodeToTree(elseif,(TreeNode)body);
           		parser.ifs.add(elseif);
           		System.out.println("If2");
	       :}|
           Else WhileForBody:body{:
           		TreeNode elseNode = new TreeNode("Else",null);
           		parser.addNodeToTree(elseNode,(TreeNode)body);
           		parser.ifs.add(elseNode);
           		System.out.println("If3");
           :}|;

/*Gramatica para operaciones matematicas*/
AddSub ::= MultDiv:MD MultipleAddSub:MAS {:
		   		parser.operations.add((TreeNode)MD);
				TreeNode AddSub = new TreeNode("ArithmeticOperation", null);
				parser.addMultipleNodes(AddSub,parser.operations,true);
				RESULT = AddSub;
				parser.operations = new ArrayList();
		   :};
MultipleAddSub ::= AddOP MultDiv:MD MultipleAddSub:MAS {:
                   		parser.operations.add((TreeNode)MD);
                   		parser.operations.add(new TreeNode("+",null));
                   :}| 
                   SubOP MultDiv:MD MultipleAddSub {:
                   		parser.operations.add((TreeNode)MD);
                   		parser.operations.add(new TreeNode("-",null));
                   :}|;
MultDiv ::= ArithmeticOperation:AOP MultipleMultDiv {:
				parser.operations.add((TreeNode)AOP);
				TreeNode multDiv = new TreeNode("MultDiv", null);
				parser.addMultipleNodes(multDiv,parser.operations,true);
				RESULT = multDiv;
				parser.operations = new ArrayList();
			:};
MultipleMultDiv ::= MultOP ArithmeticOperation:AOP MultipleMultDiv {:
						parser.operations.add((TreeNode)AOP);
						parser.operations.add(new TreeNode("*",null));
					:}| 
                    DivOP ArithmeticOperation:AOP MultipleMultDiv{:
						parser.operations.add((TreeNode)AOP);
						parser.operations.add(new TreeNode("/",null));
					:}|;
ArithmeticOperation ::= VariableName:name {:
							TreeNode idNode = new TreeNode("id", null);
							TreeNode nameNode = new TreeNode(name.toString(),null);
							parser.addNodeToTree(idNode,nameNode);  
							RESULT = idNode;
						:}| 
                        Number:number {:
                        	TreeNode idNode = new TreeNode("number", null);
							TreeNode nameNode = new TreeNode(number.toString(),null);
							parser.addNodeToTree(idNode,nameNode);
                        	RESULT = idNode;
						:}|
                        leftParenthesis AddSub:AS rightParenthesis{:
                        	TreeNode parenthesis = new TreeNode("Parenthesis", null);
                        	parser.addNodeToTree(parenthesis,(TreeNode)AS);
                        	RESULT = parenthesis;
                        :};  

/*Gramatica para comparaciones*/
ComparisonInParenthesis ::= leftParenthesis Comparison rightParenthesis{:
									TreeNode condition = new TreeNode("Conditions", null);
									int contador = -1;
									if(parser.params.size()>0){
										contador = 0;
									}
									for(int i = parser.comparisons.size()-1; i >= 0; i--){
										parser.addNodeToTree(condition,parser.comparisons.get(i));
										if(contador>-1 && contador<parser.params.size()){
											parser.addNodeToTree(condition,parser.params.get(contador));
											contador++;
										}
									}
									parser.params = new ArrayList();
									parser.comparisons = new ArrayList();
									RESULT = condition;
							:};
Comparison ::= leftValue:LV RelationalOperator:operator leftValue:RV MultipleComparison{:
						TreeNode comparison = new TreeNode("Comparison",null);
						TreeNode leftVal = new TreeNode("LeftValue", null);
						TreeNode rightVal = new TreeNode("RightValue", null);
						parser.addNodeToTree(comparison,leftVal);
						parser.addNodeToTree(comparison,(TreeNode)operator);
						parser.addNodeToTree(comparison,rightVal);
						parser.addNodeToTree(leftVal,(TreeNode)LV);
						parser.addNodeToTree(rightVal,(TreeNode)RV);
						parser.comparisons.add(comparison);
				:};
MultipleComparison ::= AndOr:AO Comparison{:
							RESULT = AO;
					   :}|;
AndOr ::= And{:RESULT = parser.params.add(new TreeNode("AND", null));:}|
          Or{:RESULT = parser.params.add(new TreeNode("OR", null));:};
RelationalOperator ::=Equal {:RESULT = new TreeNode("==",null);:}| 
                      NotEqual {:RESULT = new TreeNode("!=",null);:}| 
                      GreaterThan {:RESULT = new TreeNode(">",null);:}| 
                      LessThan {:RESULT = new TreeNode("<",null);:}| 
                      GreaterEqual {:RESULT = new TreeNode(">=",null);:}| 
                      LessEqual{:RESULT = new TreeNode("<=",null);:};

/*Gramatica para for*/
FOR ::= For paramsFor:cond WhileForBody:body{:
			TreeNode For = new TreeNode("For", null);
			parser.addNodeToTree(For,(TreeNode)cond);
			parser.addNodeToTree(For,(TreeNode)body);
			RESULT = For;
			System.out.println("For");
	    :};
paramsFor ::= leftParenthesis  declarationFor:V Delimeter rangeFor:R EOL AddSub:A rightParenthesis{:
					TreeNode node = new TreeNode("Condition", null);
					TreeNode step = new TreeNode("stepValue", null);
					parser.addNodeToTree(node,(TreeNode)V);
					parser.addNodeToTree(node,(TreeNode)R);
					parser.addNodeToTree(node,step);
					parser.addNodeToTree(step,(TreeNode)A);
					RESULT = node;
	          :};
declarationFor ::= Type:type VariableName:name {:
						TreeNode var = new TreeNode("Variable", null);
						TreeNode node =  new TreeNode("Type", null);
						TreeNode node2 =  new TreeNode("Name", null);
						TreeNode typeNode = new TreeNode(type.toString(), null);
						TreeNode nameNode = new TreeNode(name.toString(), null);
						parser.addNodeToTree(var,node);
						parser.addNodeToTree(var,node2);
						parser.addNodeToTree(node,typeNode);
						parser.addNodeToTree(node2,nameNode);
						RESULT = var;

				   :}; 
rangeFor ::= AddSub:a1 ThreePoints AddSub:a2 {:
				 TreeNode range = new TreeNode("Range", null);
				 TreeNode begin = new TreeNode("Initial Value", null);
				 TreeNode end = new TreeNode("Last Value", null);
				 parser.addNodeToTree(range,begin);
				 parser.addNodeToTree(range,end);
				 parser.addNodeToTree(begin,(TreeNode)a1);
				 parser.addNodeToTree(end,(TreeNode)a2);
				 RESULT = range;
	         :};

/*Gramatica para while*/
WHILE ::= While ComparisonInParenthesis:CP WhileForBody:body{:
				TreeNode whileNode = new TreeNode("While", null);
				parser.addNodeToTree(whileNode,(TreeNode)CP);
				parser.addNodeToTree(whileNode,(TreeNode)body);
				RESULT = whileNode;
				System.out.println("While");
		  :};
WhileForBody ::=  LeftKey BODY:body RightKey{:
						TreeNode bodyNode = new TreeNode("Body",null);
						parser.body = (ArrayList<TreeNode>)body;
						parser.addMultipleNodes(bodyNode,parser.body,false);
						RESULT = bodyNode;
				  :}|
				  LeftKey BODY error:e{:
				  		System.out.println("key2");
				  		parser.printError(eleft+1, eright+1, "Missing '}'");
				  :};